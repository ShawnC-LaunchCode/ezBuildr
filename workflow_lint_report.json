[{"filePath":"C:\\Users\\scoot\\poll\\VaultLogic\\server\\services\\WorkflowService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Section' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'LogicRule' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":56,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":65},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TransformBlock' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":110,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":124},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'WorkflowVersion' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":126,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":141},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'requireAssetAccess' is defined but never used. Allowed unused vars must match /^_/u.","line":67,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":67,"endColumn":44},{"ruleId":"max-params","severity":2,"message":"Constructor has too many parameters (6). Maximum allowed is 5.","line":83,"column":3,"nodeType":"FunctionExpression","messageId":"exceed","endLine":83,"endColumn":14},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":91,"column":38,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":91,"endColumn":40,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[2395,2397],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":92,"column":36,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":92,"endColumn":38,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[2454,2456],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":93,"column":30,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":93,"endColumn":32,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[2506,2508],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":94,"column":40,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":94,"endColumn":42,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[2565,2567],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":95,"column":50,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":95,"endColumn":52,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[2639,2641],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":96,"column":36,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":96,"endColumn":38,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[2704,2706],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":161,"column":38,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":161,"endColumn":40,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[4714,4716],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":162,"column":38,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":162,"endColumn":40,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[4763,4765],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":207,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":207,"endColumn":31},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":244,"column":48,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":244,"endColumn":50,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[7379,7381],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":249,"column":35,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":249,"endColumn":37,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[7532,7534],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"no-param-reassign","severity":2,"message":"Assignment to property of function parameter 'data'.","line":289,"column":7,"nodeType":"Identifier","messageId":"assignmentToFunctionParamProp","endLine":289,"endColumn":11},{"ruleId":"no-constant-condition","severity":2,"message":"Unexpected constant condition.","line":314,"column":12,"nodeType":"Literal","messageId":"unexpected","endLine":314,"endColumn":16},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":626,"column":42,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":626,"endColumn":44,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[18641,18690],"text":"(process.env.BASE_URL ?? process.env.VITE_BASE_URL)"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":626,"column":71,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":626,"endColumn":73,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[18691,18693],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used. Allowed unused args must match /^_/u.","line":632,"column":65,"nodeType":null,"messageId":"unusedVar","endLine":632,"endColumn":71},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":645,"column":46,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":645,"endColumn":48,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[19482,19484],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":646,"column":52,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":646,"endColumn":54,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[19551,19553],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":647,"column":50,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":647,"endColumn":52,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[19628,19630],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":648,"column":58,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":648,"endColumn":60,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[19693,19695],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"complexity","severity":2,"message":"Async arrow function has a complexity of 22. Maximum allowed is 15.","line":693,"column":27,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":833,"endColumn":6},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 43 to the 15 allowed.","line":693,"column":38,"nodeType":null,"messageId":"refactorFunction","endLine":693,"endColumn":40},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":705,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":705,"endColumn":27},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":784,"column":47,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":784,"endColumn":49,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[24654,24656],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[{"ruleId":"no-param-reassign","severity":2,"message":"Assignment to property of function parameter 'sectionData'.","line":721,"column":11,"nodeType":"Identifier","messageId":"assignmentToFunctionParamProp","endLine":721,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"max-depth","severity":2,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":767,"column":15,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":788,"endColumn":16,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"max-depth","severity":2,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":794,"column":15,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":796,"endColumn":16,"suppressions":[{"kind":"directive","justification":""},{"kind":"directive","justification":""}]}],"errorCount":30,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/* eslint-disable max-depth */\r\nimport { eq, inArray } from \"drizzle-orm\";\r\n\r\nimport type { Workflow, InsertWorkflow, Section, Step, LogicRule, WorkflowAccess, PrincipalType, AccessRole, TransformBlock, WorkflowVersion } from \"@shared/schema\";\r\nimport { workflowVersions, workflows, sections, steps, logicRules, auditLogs, projects } from \"@shared/schema\";\r\n\r\ninterface GraphConfig {\r\n  title?: string;\r\n  message?: string;\r\n  [key: string]: unknown;\r\n}\r\n\r\ninterface GraphNode {\r\n  type: string;\r\n  data?: {\r\n    config?: GraphConfig;\r\n  };\r\n}\r\n\r\ninterface GraphJson {\r\n  nodes?: GraphNode[];\r\n}\r\n\r\ninterface WorkflowSectionData {\r\n  id?: string;\r\n  title: string;\r\n  description?: string;\r\n  order?: number;\r\n  visibleIf?: string;\r\n  steps?: Array<{\r\n    id?: string;\r\n    type: string;\r\n    title: string;\r\n    description?: string;\r\n    required?: boolean;\r\n    options?: string[];\r\n    order?: number;\r\n  }>;\r\n}\r\n\r\ninterface WorkflowContentData {\r\n  title?: string;\r\n  description?: string;\r\n  sections?: WorkflowSectionData[];\r\n  logicRules?: Array<{\r\n    conditionStepAlias: string;\r\n    operator: string;\r\n    conditionValue: string;\r\n    targetType: string;\r\n    targetAlias: string;\r\n    action: string;\r\n  }>;\r\n}\r\n\r\nimport { db } from \"../db\";\r\nimport { logger } from \"../logger\";\r\nimport {\r\n  workflowRepository,\r\n  sectionRepository,\r\n  stepRepository,\r\n  logicRuleRepository,\r\n  userRepository,\r\n  workflowAccessRepository,\r\n  projectRepository,\r\n  type DbTransaction,\r\n} from \"../repositories\";\r\nimport { canAccessAsset, requireAssetAccess } from \"../utils/ownershipAccess\";\r\n\r\nimport { aclService } from \"./AclService\";\r\n\r\n\r\n/**\r\n * Service layer for workflow-related business logic\r\n */\r\nexport class WorkflowService {\r\n  private workflowRepo: typeof workflowRepository;\r\n  private sectionRepo: typeof sectionRepository;\r\n  private stepRepo: typeof stepRepository;\r\n  private logicRuleRepo: typeof logicRuleRepository;\r\n  private workflowAccessRepo: typeof workflowAccessRepository;\r\n  private projectRepo: typeof projectRepository;\r\n\r\n  constructor(\r\n    workflowRepo?: typeof workflowRepository,\r\n    sectionRepo?: typeof sectionRepository,\r\n    stepRepo?: typeof stepRepository,\r\n    logicRuleRepo?: typeof logicRuleRepository,\r\n    workflowAccessRepo?: typeof workflowAccessRepository,\r\n    projectRepo?: typeof projectRepository\r\n  ) {\r\n    this.workflowRepo = workflowRepo || workflowRepository;\r\n    this.sectionRepo = sectionRepo || sectionRepository;\r\n    this.stepRepo = stepRepo || stepRepository;\r\n    this.logicRuleRepo = logicRuleRepo || logicRuleRepository;\r\n    this.workflowAccessRepo = workflowAccessRepo || workflowAccessRepository;\r\n    this.projectRepo = projectRepo || projectRepository;\r\n  }\r\n\r\n  /**\r\n   * Verify user owns the workflow (accepts UUID or slug)\r\n   * @deprecated Use verifyAccess instead - this method only checks creatorId\r\n   */\r\n  async verifyOwnership(idOrSlug: string, userId: string): Promise<Workflow> {\r\n    const workflow = await this.workflowRepo.findByIdOrSlug(idOrSlug);\r\n\r\n    if (!workflow) {\r\n      throw new Error(\"Workflow not found\");\r\n    }\r\n\r\n    if (workflow.creatorId && workflow.creatorId !== userId) {\r\n      throw new Error(\"Access denied - you do not own this workflow\");\r\n    }\r\n\r\n    return workflow;\r\n  }\r\n\r\n  /**\r\n   * Verify user has required access level to workflow (uses ACL system + ownership)\r\n   * @param idOrSlug - Workflow ID or slug\r\n   * @param userId - User ID to check access for\r\n   * @param minRole - Minimum required role ('view', 'edit', or 'owner')\r\n   */\r\n  async verifyAccess(\r\n    idOrSlug: string,\r\n    userId: string,\r\n    minRole: Exclude<AccessRole, 'none'> = 'view'\r\n  ): Promise<Workflow> {\r\n    const workflow = await this.workflowRepo.findByIdOrSlug(idOrSlug);\r\n\r\n    if (!workflow) {\r\n      throw new Error(\"Workflow not found\");\r\n    }\r\n\r\n    // First check ownership-based access (new model)\r\n    const hasOwnershipAccess = await canAccessAsset(\r\n      userId,\r\n      workflow.ownerType,\r\n      workflow.ownerUuid\r\n    );\r\n\r\n    // If ownership access granted, allow (for MVP, members can read+write)\r\n    if (hasOwnershipAccess) {\r\n      return workflow;\r\n    }\r\n\r\n    // Fallback to ACL service for shared workflows\r\n    const hasAclAccess = await aclService.hasWorkflowRole(userId, workflow.id, minRole);\r\n\r\n    if (!hasAclAccess) {\r\n      throw new Error(\"Access denied - insufficient permissions for this workflow\");\r\n    }\r\n\r\n    return workflow;\r\n  }\r\n\r\n  /**\r\n   * Create a new workflow with a default first section\r\n   */\r\n  async createWorkflow(data: InsertWorkflow, creatorId: string): Promise<Workflow> {\r\n    // Validate ownership before creating\r\n    const ownerType = data.ownerType || 'user';\r\n    const ownerUuid = data.ownerUuid || creatorId;\r\n\r\n    const { canCreateWithOwnership } = await import('../utils/ownershipAccess');\r\n    const canCreate = await canCreateWithOwnership(creatorId, ownerType, ownerUuid);\r\n    if (!canCreate) {\r\n      throw new Error('Access denied: You do not have permission to create assets with this ownership');\r\n    }\r\n\r\n    return this.workflowRepo.transaction(async (tx) => {\r\n      // Create workflow\r\n      const workflow = await this.workflowRepo.create(\r\n        {\r\n          ...data,\r\n          creatorId,\r\n          ownerId: creatorId, // Creator is also the initial owner (legacy)\r\n          ownerType,\r\n          ownerUuid,\r\n          status: 'draft',\r\n        },\r\n        tx\r\n      );\r\n\r\n      // Create default first section\r\n      await this.sectionRepo.create(\r\n        {\r\n          workflowId: workflow.id,\r\n          title: 'Section 1',\r\n          order: 1,\r\n        },\r\n        tx\r\n      );\r\n\r\n      return workflow;\r\n    });\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Get workflow by ID with full details (sections, steps, rules)\r\n   *\r\n   * PERFORMANCE OPTIMIZED (Dec 2025):\r\n   * - Uses Map for O(n) step grouping instead of O(n*m) filter\r\n   * - Batch loads all data in parallel where possible\r\n   */\r\n  async getWorkflowWithDetails(workflowId: string, userId: string) {\r\n    const workflow = await this.verifyAccess(workflowId, userId, 'view');\r\n\r\n    // OPTIMIZATION: Run independent queries in parallel\r\n    const [sections, logicRules, transformBlocks] = await Promise.all([\r\n      this.sectionRepo.findByWorkflowId(workflowId),\r\n      this.logicRuleRepo.findByWorkflowId(workflowId),\r\n      db.query.transformBlocks.findMany({\r\n        where: (tb, { eq }) => eq(tb.workflowId, workflowId),\r\n      }),\r\n    ]);\r\n\r\n    const sectionIds = sections.map((s) => s.id);\r\n    const steps = sectionIds.length > 0\r\n      ? await this.stepRepo.findBySectionIds(sectionIds)\r\n      : [];\r\n\r\n    // Debug logging for preview issue\r\n    logger.info({\r\n      workflowId,\r\n      userId,\r\n      sectionsCount: sections.length,\r\n      stepsCount: steps.length,\r\n      logicRulesCount: logicRules.length\r\n    }, 'getWorkflowWithDetails called');\r\n\r\n    // OPTIMIZATION: Group steps by section using Map (O(n) instead of O(n*m))\r\n    const stepsBySectionMap = new Map<string, Step[]>();\r\n    for (const step of steps) {\r\n      if (!stepsBySectionMap.has(step.sectionId)) {\r\n        stepsBySectionMap.set(step.sectionId, []);\r\n      }\r\n      stepsBySectionMap.get(step.sectionId)!.push(step);\r\n    }\r\n\r\n    const sectionsWithSteps = sections.map((section) => ({\r\n      ...section,\r\n      steps: stepsBySectionMap.get(section.id) || [],\r\n    }));\r\n\r\n    // OPTIMIZATION: Single query for current version (if exists)\r\n    let currentVersion = null;\r\n    if (workflow.currentVersionId || workflow.status === 'draft') {\r\n      currentVersion = await db.query.workflowVersions.findFirst({\r\n        where: workflow.currentVersionId\r\n          ? eq(workflowVersions.id, workflow.currentVersionId)\r\n          : eq(workflowVersions.workflowId, workflowId),\r\n        orderBy: workflow.currentVersionId\r\n          ? undefined\r\n          : (v, { desc }) => [desc(v.versionNumber)],\r\n      });\r\n    }\r\n\r\n    return {\r\n      ...workflow,\r\n      sections: sectionsWithSteps,\r\n      logicRules,\r\n      transformBlocks,\r\n      currentVersion,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * List workflows for a user (Owner OR Shared)\r\n   */\r\n  async listWorkflows(userId: string): Promise<Workflow[]> {\r\n    // Stage 15: Updated to include shared workflows\r\n    return this.workflowRepo.findByUserAccess(userId);\r\n  }\r\n\r\n  /**\r\n   * Update workflow\r\n   */\r\n  async updateWorkflow(\r\n    workflowId: string,\r\n    userId: string,\r\n    data: Partial<InsertWorkflow>\r\n  ): Promise<Workflow> {\r\n    await this.verifyAccess(workflowId, userId, 'edit');\r\n\r\n    // If slug is being updated, ensure it's unique\r\n    if (data.slug) {\r\n      data.slug = await this.ensureUniqueSlug(data.slug, workflowId);\r\n    }\r\n\r\n    return this.workflowRepo.update(workflowId, data);\r\n  }\r\n\r\n  // ... (keep existing methods)\r\n\r\n  /**\r\n   * Ensure slug is unique by appending counter if necessary\r\n   */\r\n  async ensureUniqueSlug(slug: string, workflowId: string): Promise<string> {\r\n    // 1. Sanitize the base slug\r\n    let baseSlug = slug\r\n      .toLowerCase()\r\n      .replace(/[^a-z0-9]+/g, '-')\r\n      .replace(/^-+|-+$/g, '');\r\n\r\n    // Ensure it's not empty\r\n    if (!baseSlug) { baseSlug = 'workflow'; }\r\n\r\n    // 2. Check strict existence of the requested slug\r\n    let candidate = baseSlug;\r\n    let counter = 2;\r\n\r\n    while (true) {\r\n      const existing = await this.workflowRepo.findBySlug(candidate);\r\n\r\n      // If no workflow has this slug, OR the one that has it is THIS workflow, it's safe\r\n      if (!existing || existing.id === workflowId) {\r\n        return candidate;\r\n      }\r\n\r\n      // Conflict found - try next counter\r\n      candidate = `${baseSlug}-${counter}`;\r\n      counter++;\r\n\r\n      // Safety break to prevent infinite loops (unlikely but good practice)\r\n      if (counter > 100) {\r\n        // Fallback to random ID suffix if 100 collisions\r\n        return `${baseSlug}-${Math.random().toString(36).substring(2, 8)}`;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete workflow\r\n   */\r\n  async deleteWorkflow(workflowId: string, userId: string): Promise<void> {\r\n    await this.verifyAccess(workflowId, userId, 'owner');\r\n    await this.workflowRepo.delete(workflowId);\r\n  }\r\n\r\n  /**\r\n   * Change workflow status\r\n   */\r\n  async changeStatus(\r\n    workflowId: string,\r\n    userId: string,\r\n    status: 'draft' | 'active' | 'archived'\r\n  ): Promise<Workflow> {\r\n    await this.verifyAccess(workflowId, userId, 'edit');\r\n    return this.workflowRepo.update(workflowId, { status });\r\n  }\r\n\r\n  /**\r\n   * Ensure workflow is in draft status before editing\r\n   * Auto-reverts active/archived workflows to draft\r\n   * Returns true if workflow was auto-reverted, false otherwise\r\n   */\r\n  async ensureDraftForEditing(\r\n    workflowId: string,\r\n    userId: string\r\n  ): Promise<boolean> {\r\n    await this.verifyAccess(workflowId, userId, 'edit');\r\n    const workflow = await this.workflowRepo.findById(workflowId);\r\n\r\n    if (!workflow) {\r\n      throw new Error('Workflow not found');\r\n    }\r\n\r\n    // If already draft, no action needed\r\n    if (workflow.status === 'draft') {\r\n      return false;\r\n    }\r\n\r\n    // Auto-revert to draft\r\n    await this.workflowRepo.update(workflowId, { status: 'draft' });\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Move workflow to a project (or unfiled if projectId is null)\r\n   * Verifies:\r\n   * - User owns the workflow\r\n   * - If moving to a project, user has access to that project\r\n   */\r\n  async moveToProject(\r\n    workflowId: string,\r\n    userId: string,\r\n    projectId: string | null\r\n  ): Promise<Workflow> {\r\n    // Verify user has owner access to the workflow\r\n    await this.verifyAccess(workflowId, userId, 'owner');\r\n\r\n    // If moving to a project (not unfiled), verify user has access to target project\r\n    if (projectId !== null) {\r\n      const project = await this.projectRepo.findById(projectId);\r\n\r\n      if (!project) {\r\n        throw new Error(\"Target project not found\");\r\n      }\r\n\r\n      // Verify user owns or has access to the target project (use ACL)\r\n      const hasProjectAccess = await aclService.hasProjectRole(userId, projectId, 'edit');\r\n      if (!hasProjectAccess) {\r\n        throw new Error(\"Access denied - you do not have access to the target project\");\r\n      }\r\n    }\r\n\r\n    return this.workflowRepo.moveToProject(workflowId, projectId);\r\n  }\r\n\r\n  /**\r\n   * Get unfiled workflows (workflows with no project) for a creator\r\n   */\r\n  async listUnfiledWorkflows(creatorId: string): Promise<Workflow[]> {\r\n    return this.workflowRepo.findUnfiledByCreatorId(creatorId);\r\n  }\r\n\r\n  /**\r\n   * Get resolved mode for a workflow (modeOverride ?? user.defaultMode)\r\n   */\r\n  async getResolvedMode(\r\n    workflowId: string,\r\n    userId: string\r\n  ): Promise<{ mode: 'easy' | 'advanced', source: 'workflow' | 'user' }> {\r\n    const workflow = await this.verifyAccess(workflowId, userId, 'view');\r\n    const user = await userRepository.findById(userId);\r\n\r\n    if (!user) {\r\n      throw new Error(\"User not found\");\r\n    }\r\n\r\n    // If workflow has a mode override, use it\r\n    if (workflow.modeOverride) {\r\n      return {\r\n        mode: workflow.modeOverride as 'easy' | 'advanced',\r\n        source: 'workflow',\r\n      };\r\n    }\r\n\r\n    // Otherwise, use user's default mode\r\n    return {\r\n      mode: (user.defaultMode as 'easy' | 'advanced') || 'easy',\r\n      source: 'user',\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set or clear workflow mode override\r\n   */\r\n  async setModeOverride(\r\n    workflowId: string,\r\n    userId: string,\r\n    modeOverride: 'easy' | 'advanced' | null\r\n  ): Promise<Workflow> {\r\n    await this.verifyAccess(workflowId, userId, 'edit');\r\n\r\n    // Validate mode value if not null\r\n    if (modeOverride !== null && !['easy', 'advanced'].includes(modeOverride)) {\r\n      throw new Error(\"Invalid mode value. Must be 'easy', 'advanced', or null\");\r\n    }\r\n\r\n    return this.workflowRepo.update(workflowId, { modeOverride });\r\n  }\r\n\r\n  // ===================================================================\r\n  // ACL MANAGEMENT METHODS\r\n  // ===================================================================\r\n\r\n  /**\r\n   * Get all ACL entries for a workflow\r\n   */\r\n  async getWorkflowAccess(workflowId: string, userId: string, tx?: DbTransaction): Promise<WorkflowAccess[]> {\r\n    await this.verifyAccess(workflowId, userId, 'view');\r\n    return this.workflowAccessRepo.findByWorkflowId(workflowId, tx);\r\n  }\r\n\r\n  /**\r\n   * Grant or update access to a workflow\r\n   * Only owner can grant 'owner' role to others\r\n   */\r\n  async grantWorkflowAccess(\r\n    workflowId: string,\r\n    requestorId: string,\r\n    entries: Array<{ principalType: PrincipalType; principalId: string; role: string }>,\r\n    tx?: DbTransaction\r\n  ): Promise<WorkflowAccess[]> {\r\n    const workflow = await this.verifyAccess(workflowId, requestorId, 'owner');\r\n\r\n    const results: WorkflowAccess[] = [];\r\n\r\n    for (const entry of entries) {\r\n      // Only owner can grant 'owner' role\r\n      if (entry.role === 'owner' && workflow.ownerId !== requestorId) {\r\n        throw new Error(\"Only the workflow owner can grant owner access to others\");\r\n      }\r\n\r\n      const acl = await this.workflowAccessRepo.upsert(\r\n        workflowId,\r\n        entry.principalType,\r\n        entry.principalId,\r\n        entry.role,\r\n        tx\r\n      );\r\n      results.push(acl);\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Revoke access from a workflow\r\n   */\r\n  async revokeWorkflowAccess(\r\n    workflowId: string,\r\n    requestorId: string,\r\n    entries: Array<{ principalType: PrincipalType; principalId: string }>,\r\n    tx?: DbTransaction\r\n  ): Promise<void> {\r\n    await this.verifyAccess(workflowId, requestorId, 'owner');\r\n\r\n    for (const entry of entries) {\r\n      await this.workflowAccessRepo.deleteByPrincipal(\r\n        workflowId,\r\n        entry.principalType,\r\n        entry.principalId,\r\n        tx\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transfer workflow ownership to another user\r\n   * Only current owner can transfer ownership\r\n   */\r\n  async transferWorkflowOwnership(\r\n    workflowId: string,\r\n    currentOwnerId: string,\r\n    newOwnerId: string,\r\n    tx?: DbTransaction\r\n  ): Promise<Workflow> {\r\n    const workflow = await this.verifyAccess(workflowId, currentOwnerId, 'owner');\r\n\r\n    // Additionally verify this user is the actual owner (not just has 'owner' role via ACL)\r\n    if (workflow.ownerId !== currentOwnerId) {\r\n      throw new Error(\"Only the current owner can transfer ownership\");\r\n    }\r\n\r\n    return this.workflowRepo.update(\r\n      workflowId,\r\n      {\r\n        ownerId: newOwnerId,\r\n      },\r\n      tx\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Update workflow intake configuration (Stage 12.5)\r\n   * Owner and edit access can update intake config\r\n   */\r\n  async updateIntakeConfig(\r\n    workflowId: string,\r\n    userId: string,\r\n    intakeConfig: Record<string, unknown>,\r\n    tx?: DbTransaction\r\n  ): Promise<Workflow> {\r\n    // Verify user has edit access\r\n    await this.verifyAccess(workflowId, userId, 'edit');\r\n\r\n    return this.workflowRepo.update(\r\n      workflowId,\r\n      {\r\n        intakeConfig,\r\n      },\r\n      tx\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Generate or retrieve public link for a workflow\r\n   * Creates a unique slug-based link if one doesn't exist\r\n   */\r\n  async getOrGeneratePublicLink(workflowId: string, userId: string): Promise<string> {\r\n    const workflow = await this.verifyAccess(workflowId, userId, 'edit');\r\n\r\n    // If publicLink already exists, return it\r\n    if (workflow.publicLink) {\r\n      return this.constructPublicUrl(workflow.publicLink);\r\n    }\r\n\r\n    // Generate a unique slug (using robust logic now)\r\n    const slug = await this.ensureUniqueSlug(workflow.title, workflowId);\r\n\r\n    // Update workflow with new publicLink\r\n    await this.workflowRepo.update(workflowId, {\r\n      publicLink: slug,\r\n      isPublic: true\r\n    });\r\n\r\n    return this.constructPublicUrl(slug);\r\n  }\r\n\r\n  /**\r\n   * Generate a URL-friendly slug from workflow title and ID\r\n   * @deprecated logic moved to ensureUniqueSlug\r\n   */\r\n  private generateSlug(title: string, workflowId: string): string {\r\n    // Take first 6 characters of workflow ID for uniqueness\r\n    const shortId = workflowId.substring(0, 6);\r\n\r\n    // Convert title to lowercase, replace spaces and special chars with hyphens\r\n    const titleSlug = title\r\n      .toLowerCase()\r\n      .replace(/[^a-z0-9]+/g, '-')\r\n      .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens\r\n      .substring(0, 50); // Limit length\r\n\r\n    return `${titleSlug}-${shortId}`;\r\n  }\r\n\r\n  /**\r\n   * Construct full public URL from slug\r\n   */\r\n  private constructPublicUrl(slug: string): string {\r\n    const baseUrl = process.env.BASE_URL || process.env.VITE_BASE_URL || 'http://localhost:5000';\r\n    return `${baseUrl}/run/${slug}`;\r\n  }\r\n  /**\r\n   * Specifically ensures 'final' nodes are converted to Final Sections for the Runner\r\n   */\r\n  async syncWithGraph(workflowId: string, graphJson: GraphJson, userId: string): Promise<void> {\r\n    if (!graphJson?.nodes) { return; }\r\n\r\n    // 1. Find 'final' node in graph\r\n    const finalNode = graphJson.nodes.find((n) => n.type === 'final');\r\n\r\n    // 2. Manage Final Document Section\r\n    const existingSections = await this.sectionRepo.findByWorkflowId(workflowId);\r\n    const finalSection = existingSections.find(s => (s.config as Record<string, unknown>)?.finalBlock === true);\r\n\r\n    if (finalNode) {\r\n      const sectionConfig = {\r\n        finalBlock: true,\r\n        title: finalNode.data?.config?.title || \"Completion\",\r\n        screenTitle: finalNode.data?.config?.title || \"Completion\", // Legacy\r\n        message: finalNode.data?.config?.message || \"\",\r\n        markdownMessage: finalNode.data?.config?.message || \"\", // Legacy\r\n        ...finalNode.data?.config\r\n      };\r\n\r\n      if (finalSection) {\r\n        // Update existing\r\n        await this.sectionRepo.update(finalSection.id, {\r\n          title: sectionConfig.screenTitle,\r\n          config: sectionConfig\r\n        });\r\n      } else {\r\n        // Create new\r\n        // Determine order: last + 1\r\n        const maxOrder = existingSections.length > 0 ? Math.max(...existingSections.map(s => s.order)) : 0;\r\n\r\n        await this.sectionRepo.create({\r\n          workflowId,\r\n          title: sectionConfig.screenTitle,\r\n          order: maxOrder + 1,\r\n          config: sectionConfig\r\n        });\r\n      }\r\n    } else {\r\n      // If final node removed, remove final section? \r\n      // For safety, we might keep it or mark it invisible, but deleting is cleaner if we assume graph is truth.\r\n      if (finalSection) {\r\n        await this.sectionRepo.delete(finalSection.id);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Replace full workflow content (Deep Update)\r\n   * Used by AI Assistant to apply full structural changes\r\n   */\r\n  async replaceWorkflowContent(\r\n    workflowId: string,\r\n    userId: string,\r\n    data: WorkflowContentData\r\n  ): Promise<Workflow> {\r\n    // 1. Authorization\r\n    const hasAccess = await aclService.hasWorkflowRole(userId, workflowId, 'edit');\r\n    if (!hasAccess) {\r\n      throw new Error(\"Access denied - you do not have permission to edit this workflow\");\r\n    }\r\n\r\n    return db.transaction(async (tx) => {\r\n      // 2. Update Workflow Metadata\r\n      const [updatedWorkflow] = await tx\r\n        .update(workflows)\r\n        .set({\r\n          title: data.title,\r\n          description: data.description,\r\n          updatedAt: new Date(),\r\n        })\r\n        .where(eq(workflows.id, workflowId))\r\n        .returning();\r\n\r\n      if (!updatedWorkflow) {\r\n        throw new Error(\"Workflow not found\");\r\n      }\r\n\r\n      // 3. Sync Sections\r\n      const existingSections = await tx\r\n        .select()\r\n        .from(sections)\r\n        .where(eq(sections.workflowId, workflowId));\r\n\r\n      const existingSectionIds = new Set(existingSections.map(s => s.id));\r\n      const incomingSectionIds = new Set<string>();\r\n\r\n      if (Array.isArray(data.sections)) {\r\n        data.sections.forEach((sectionData, index: number) => {\r\n          // eslint-disable-next-line no-param-reassign\r\n          sectionData.order = sectionData.order ?? index;\r\n        });\r\n\r\n        for (const sectionData of data.sections) {\r\n          let sectionId = sectionData.id;\r\n          const isExisting = (sectionId !== undefined && sectionId !== null) && existingSectionIds.has(sectionId);\r\n\r\n          if (isExisting) {\r\n            incomingSectionIds.add(sectionId);\r\n            await tx\r\n              .update(sections)\r\n              .set({\r\n                title: sectionData.title,\r\n                description: sectionData.description,\r\n                order: sectionData.order,\r\n                visibleIf: sectionData.visibleIf,\r\n              })\r\n              .where(eq(sections.id, sectionId));\r\n          } else {\r\n            const [newSection] = await tx\r\n              .insert(sections)\r\n              .values({\r\n                workflowId,\r\n                title: sectionData.title,\r\n                description: sectionData.description,\r\n                order: sectionData.order,\r\n                visibleIf: sectionData.visibleIf,\r\n              })\r\n              .returning();\r\n            sectionId = newSection.id;\r\n          }\r\n\r\n          // 4. Sync Steps\r\n          if (Array.isArray(sectionData.steps)) {\r\n            let existingStepIds = new Set<string>();\r\n            if (isExisting) {\r\n              const dbSteps = await tx.select().from(steps).where(eq(steps.sectionId, sectionId));\r\n              existingStepIds = new Set(dbSteps.map(s => s.id));\r\n            }\r\n            const incomingStepIds = new Set<string>();\r\n\r\n            // eslint-disable-next-line max-depth\r\n            for (const [stepIndex, stepData] of sectionData.steps.entries()) {\r\n              const stepId = stepData.id;\r\n              const isStepExisting = (stepId !== undefined && stepId !== null) && existingStepIds.has(stepId);\r\n\r\n              if (isStepExisting) {\r\n                incomingStepIds.add(stepId);\r\n                await tx.update(steps).set({\r\n                  title: stepData.title,\r\n                  description: stepData.description,\r\n                  type: stepData.type,\r\n                  required: stepData.required,\r\n                  options: stepData.options,\r\n                  order: stepData.order ?? stepIndex,\r\n                  sectionId,\r\n                }).where(eq(steps.id, stepId));\r\n              } else {\r\n                await tx.insert(steps).values({\r\n                  sectionId,\r\n                  type: stepData.type,\r\n                  title: stepData.title,\r\n                  description: stepData.description,\r\n                  required: stepData.required || false,\r\n                  options: stepData.options ?? [],\r\n                  order: stepData.order ?? stepIndex,\r\n                });\r\n              }\r\n            }\r\n\r\n            if (isExisting) {\r\n              const stepsToDelete = [...existingStepIds].filter(id => !incomingStepIds.has(id));\r\n              // eslint-disable-next-line max-depth\r\n              if (stepsToDelete.length > 0) {\r\n                await tx.delete(steps).where(inArray(steps.id, stepsToDelete));\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const sectionsToDelete = [...existingSectionIds].filter(id => !incomingSectionIds.has(id));\r\n      if (sectionsToDelete.length > 0) {\r\n        await tx.delete(sections).where(inArray(sections.id, sectionsToDelete));\r\n      }\r\n\r\n      // 5. Logic Rules\r\n      await tx.delete(logicRules).where(eq(logicRules.workflowId, workflowId));\r\n\r\n      if (Array.isArray(data.logicRules) && data.logicRules.length > 0) {\r\n        await tx.insert(logicRules).values(\r\n          data.logicRules.map((rule) => ({\r\n            workflowId,\r\n            conditionStepAlias: rule.conditionStepAlias,\r\n            operator: rule.operator,\r\n            conditionValue: rule.conditionValue,\r\n            targetType: rule.targetType as 'section' | 'step',\r\n            targetAlias: rule.targetAlias,\r\n            action: rule.action,\r\n          }))\r\n        );\r\n      }\r\n\r\n      await db.insert(auditLogs).values({\r\n        actorId: userId,\r\n        entityType: 'workflow',\r\n        entityId: workflowId,\r\n        action: 'ai_revision_apply',\r\n        diff: { summary: 'Full content replaced by AI' },\r\n      });\r\n\r\n      return updatedWorkflow;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Transfer workflow ownership (new ownership model)\r\n   * Detaches from project if transferring to different owner than project\r\n   *\r\n   * @param workflowId - Workflow to transfer\r\n   * @param userId - User requesting transfer\r\n   * @param targetOwnerType - 'user' or 'org'\r\n   * @param targetOwnerUuid - UUID of target owner\r\n   * @returns Workflow with optional detachment warning\r\n   */\r\n  async transferOwnership(\r\n    workflowId: string,\r\n    userId: string,\r\n    targetOwnerType: 'user' | 'org',\r\n    targetOwnerUuid: string\r\n  ): Promise<Workflow & { detachedFromProject?: boolean; detachmentReason?: string }> {\r\n    const { transferService } = await import('./TransferService');\r\n    const workflow = await this.verifyAccess(workflowId, userId, 'edit');\r\n\r\n    // Validate transfer permissions\r\n    await transferService.validateTransfer(\r\n      userId,\r\n      workflow.ownerType,\r\n      workflow.ownerUuid,\r\n      targetOwnerType,\r\n      targetOwnerUuid\r\n    );\r\n\r\n    // Check if workflow is in a project\r\n    let shouldDetachFromProject = false;\r\n    if (workflow.projectId) {\r\n      const project = await db.query.projects.findFirst({\r\n        where: eq(projects.id, workflow.projectId),\r\n      });\r\n\r\n      // Detach if project ownership differs from target ownership\r\n      if (project && (project.ownerType !== targetOwnerType || project.ownerUuid !== targetOwnerUuid)) {\r\n        shouldDetachFromProject = true;\r\n      }\r\n    }\r\n\r\n    // Update workflow ownership\r\n    const updateData: Partial<InsertWorkflow> = {\r\n      ownerType: targetOwnerType,\r\n      ownerUuid: targetOwnerUuid,\r\n    };\r\n\r\n    // Detach from project if needed\r\n    if (shouldDetachFromProject) {\r\n      updateData.projectId = null;\r\n    }\r\n\r\n    // Update workflow ownership\r\n    const updatedWorkflow = await this.workflowRepo.update(workflowId, updateData);\r\n\r\n    // Cascade ownership to all runs for this workflow\r\n    const { workflowRuns } = await import('@shared/schema');\r\n    await db\r\n      .update(workflowRuns)\r\n      .set({\r\n        ownerType: targetOwnerType,\r\n        ownerUuid: targetOwnerUuid,\r\n      })\r\n      .where(eq(workflowRuns.workflowId, workflowId));\r\n\r\n    // Return workflow with detachment notification if applicable\r\n    if (shouldDetachFromProject) {\r\n      return {\r\n        ...updatedWorkflow,\r\n        detachedFromProject: true,\r\n        detachmentReason: 'Workflow was removed from its project because the project has different ownership',\r\n      };\r\n    }\r\n\r\n    return updatedWorkflow;\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nexport const workflowService = new WorkflowService();\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]