[{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\AIError.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[221,224],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[221,224],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[427,430],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[427,430],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[597,600],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[597,600],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":36,"column":5,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":36,"endColumn":27},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":41,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":41,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":53,"column":7,"nodeType":"Property","messageId":"anyAssignment","endLine":53,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":84,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1940,1943],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1940,1943],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":94,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2185,2188],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2185,2188],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of an `any` typed value.","line":95,"column":3,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":102,"endColumn":5},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .code on an `any` value.","line":96,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":96,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .status on an `any` value.","line":97,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":97,"endColumn":18},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .code on an `any` value.","line":98,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":98,"endColumn":16},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":99,"column":5,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":99,"endColumn":36,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[2331,2362],"text":"(Boolean((error?.message?.includes('429'))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":99,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":99,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":99,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":99,"endColumn":19},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":100,"column":5,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":100,"endColumn":47,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[2371,2413],"text":"(Boolean((error?.message?.includes('Quota exceeded'))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":100,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":100,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":100,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":100,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":101,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":101,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":101,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":101,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":108,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2559,2562],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2559,2562],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of an `any` typed value.","line":109,"column":3,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":114,"endColumn":5},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .code on an `any` value.","line":110,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":110,"endColumn":16},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .code on an `any` value.","line":111,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":111,"endColumn":16},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":112,"column":5,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":112,"endColumn":40,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[2662,2697],"text":"(Boolean((error?.message?.includes('timeout'))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":112,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":112,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":112,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":112,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":113,"column":5,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":113,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":113,"column":12,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":113,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":120,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2846,2849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2846,2849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":122,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":122,"endColumn":48,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[2913,2954],"text":"Boolean((error?.response?.headers?.['retry-after']))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .response on an `any` value.","line":122,"column":14,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":122,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":123,"column":33,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":123,"endColumn":70},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .response on an `any` value.","line":123,"column":39,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":123,"endColumn":47},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":130,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":130,"endColumn":54,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3180,3227],"text":"Boolean((error?.response?.headers?.['x-ratelimit-reset']))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .response on an `any` value.","line":130,"column":14,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":130,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":131,"column":32,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":131,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .response on an `any` value.","line":131,"column":38,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":131,"endColumn":46},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":192,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":192,"endColumn":32},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":217,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5759,5762],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5759,5762],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .code on an `any` value.","line":218,"column":59,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":218,"endColumn":63}],"suppressedMessages":[],"errorCount":41,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * AI Error Handling\r\n *\r\n * Unified error handling for all AI services\r\n */\r\n\r\nimport type { AIErrorCode } from './types';\r\n\r\nexport interface AIErrorDetails {\r\n  code: AIErrorCode;\r\n  message: string;\r\n  details?: any;\r\n  retryable?: boolean;\r\n  retryAfterSeconds?: number;\r\n}\r\n\r\n/**\r\n * Custom AI Error class\r\n */\r\nexport class AIError extends Error {\r\n  public readonly code: AIErrorCode;\r\n  public readonly details?: any;\r\n  public readonly retryable: boolean;\r\n  public readonly retryAfterSeconds?: number;\r\n\r\n  constructor(\r\n    message: string,\r\n    code: AIErrorCode,\r\n    details?: any,\r\n    retryable = false,\r\n    retryAfterSeconds?: number\r\n  ) {\r\n    super(message);\r\n    this.name = 'AIError';\r\n    this.code = code;\r\n    this.details = details;\r\n    this.retryable = retryable;\r\n    this.retryAfterSeconds = retryAfterSeconds;\r\n\r\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, AIError);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert to JSON for API responses\r\n   */\r\n  toJSON(): AIErrorDetails {\r\n    return {\r\n      code: this.code,\r\n      message: this.message,\r\n      details: this.details,\r\n      retryable: this.retryable,\r\n      retryAfterSeconds: this.retryAfterSeconds,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create error from unknown error object\r\n   */\r\n  static fromUnknown(error: unknown, defaultCode: AIErrorCode = 'API_ERROR'): AIError {\r\n    if (error instanceof AIError) {\r\n      return error;\r\n    }\r\n\r\n    if (error instanceof Error) {\r\n      return new AIError(error.message, defaultCode, {\r\n        originalError: error.name,\r\n        stack: error.stack,\r\n      });\r\n    }\r\n\r\n    return new AIError(String(error), defaultCode);\r\n  }\r\n}\r\n\r\n/**\r\n * Create an AI error (factory function for backwards compatibility)\r\n */\r\nexport function createAIError(\r\n  message: string,\r\n  code: AIErrorCode,\r\n  details?: any,\r\n  retryable = false,\r\n  retryAfterSeconds?: number\r\n): AIError {\r\n  return new AIError(message, code, details, retryable, retryAfterSeconds);\r\n}\r\n\r\n/**\r\n * Check if error is a rate limit error\r\n */\r\nexport function isRateLimitError(error: any): boolean {\r\n  return (\r\n    error?.code === 'RATE_LIMIT' ||\r\n    error?.status === 429 ||\r\n    error?.code === 'rate_limit_exceeded' ||\r\n    error?.message?.includes('429') ||\r\n    error?.message?.includes('Quota exceeded') ||\r\n    error?.message?.includes('rate limit')\r\n  );\r\n}\r\n\r\n/**\r\n * Check if error is a timeout error\r\n */\r\nexport function isTimeoutError(error: any): boolean {\r\n  return (\r\n    error?.code === 'TIMEOUT' ||\r\n    error?.code === 'ETIMEDOUT' ||\r\n    error?.message?.includes('timeout') ||\r\n    error?.message?.includes('timed out')\r\n  );\r\n}\r\n\r\n/**\r\n * Extract retry-after seconds from error\r\n */\r\nexport function getRetryAfter(error: any): number {\r\n  // Check for Retry-After header (seconds)\r\n  if (error?.response?.headers?.['retry-after']) {\r\n    const retryAfter = parseInt(error.response.headers['retry-after'], 10);\r\n    if (!isNaN(retryAfter)) {\r\n      return retryAfter * 1000; // Convert to ms\r\n    }\r\n  }\r\n\r\n  // Check for rate limit reset timestamp\r\n  if (error?.response?.headers?.['x-ratelimit-reset']) {\r\n    const resetTime = parseInt(error.response.headers['x-ratelimit-reset'], 10);\r\n    if (!isNaN(resetTime)) {\r\n      const now = Math.floor(Date.now() / 1000);\r\n      const waitSeconds = Math.max(0, resetTime - now);\r\n      return waitSeconds * 1000; // Convert to ms\r\n    }\r\n  }\r\n\r\n  // Default to 60 seconds if no info available\r\n  return 60000;\r\n}\r\n\r\n/**\r\n * Quality threshold details for quality rejection errors\r\n */\r\nexport interface QualityThresholdDetails {\r\n  qualityScore: number;\r\n  threshold: number;\r\n  issues: Array<{\r\n    type: 'error' | 'warning' | 'suggestion';\r\n    category: string;\r\n    message: string;\r\n    location?: string;\r\n    suggestion?: string;\r\n  }>;\r\n  suggestions: string[];\r\n  breakdown: {\r\n    aliases: number;\r\n    types: number;\r\n    structure: number;\r\n    ux: number;\r\n    completeness: number;\r\n    validation: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Quality Threshold Error - thrown when AI-generated workflow quality is below minimum threshold\r\n */\r\nexport class QualityThresholdError extends AIError {\r\n  public readonly qualityScore: number;\r\n  public readonly threshold: number;\r\n  public readonly qualityIssues: QualityThresholdDetails['issues'];\r\n  public readonly qualitySuggestions: string[];\r\n  public readonly qualityBreakdown: QualityThresholdDetails['breakdown'];\r\n\r\n  constructor(details: QualityThresholdDetails) {\r\n    super(\r\n      `Generated workflow quality score (${details.qualityScore}) is below minimum threshold (${details.threshold})`,\r\n      'QUALITY_THRESHOLD',\r\n      details,\r\n      false // not retryable automatically\r\n    );\r\n    this.name = 'QualityThresholdError';\r\n    this.qualityScore = details.qualityScore;\r\n    this.threshold = details.threshold;\r\n    this.qualityIssues = details.issues;\r\n    this.qualitySuggestions = details.suggestions;\r\n    this.qualityBreakdown = details.breakdown;\r\n\r\n    // Maintains proper stack trace\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, QualityThresholdError);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert to JSON for API responses\r\n   */\r\n  toJSON(): AIErrorDetails & { quality: QualityThresholdDetails } {\r\n    return {\r\n      ...super.toJSON(),\r\n      quality: {\r\n        qualityScore: this.qualityScore,\r\n        threshold: this.threshold,\r\n        issues: this.qualityIssues,\r\n        suggestions: this.qualitySuggestions,\r\n        breakdown: this.qualityBreakdown,\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check if error is a quality threshold error\r\n */\r\nexport function isQualityThresholdError(error: any): error is QualityThresholdError {\r\n  return error instanceof QualityThresholdError || error?.code === 'QUALITY_THRESHOLD';\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\AIPromptBuilder.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":199,"column":45,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":199,"endColumn":47,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[9024,9026],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":200,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":200,"endColumn":48,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9056,9079],"text":"(constraints.maxSections != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[9056,9079],"text":"(constraints.maxSections ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9056,9079],"text":"(Boolean(constraints.maxSections))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":200,"column":49,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":200,"endColumn":51,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[9080,9082],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":201,"column":32,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":201,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[9119,9149],"text":"(constraints.maxStepsPerSection != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[9119,9149],"text":"(constraints.maxStepsPerSection ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[9119,9149],"text":"(Boolean(constraints.maxStepsPerSection))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":201,"column":63,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":201,"endColumn":65,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[9150,9152],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":331,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":331,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14678,14681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14678,14681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * AI Prompt Builder Service\r\n *\r\n * Centralizes prompt construction for all AI operations\r\n */\r\n\r\nimport type {\r\n  AIWorkflowGenerationRequest,\r\n  AIWorkflowSuggestionRequest,\r\n  AIWorkflowRevisionRequest,\r\n  AIConnectLogicRequest,\r\n  AIDebugLogicRequest,\r\n  AIVisualizeLogicRequest,\r\n  WorkflowCategory,\r\n} from '../../../shared/types/ai';\r\n\r\nexport class AIPromptBuilder {\r\n  /**\r\n   * Get domain-specific guidance for a workflow category\r\n   */\r\n  public getCategoryGuidance(category: WorkflowCategory): string {\r\n    const guidance: Record<WorkflowCategory, string> = {\r\n      application: `\r\nDOMAIN: APPLICATION WORKFLOWS (Job apps, loan apps, permits, registrations)\r\nBest practices:\r\n- Start with applicant identification (name, email, phone)\r\n- Group eligibility questions early to screen out ineligible applicants\r\n- Use date fields for DOB, start dates, availability\r\n- Include file uploads for supporting documents (resume, ID, certificates)\r\n- End with attestation/signature and submission confirmation\r\n- Use conditional logic to show relevant sections based on applicant type\r\n\r\nRecommended sections: Applicant Information, Eligibility, Background, Documents, Certification`,\r\n\r\n      survey: `\r\nDOMAIN: SURVEY WORKFLOWS (Feedback, NPS, satisfaction, polls)\r\nBest practices:\r\n- Keep it concise (aim for 5-10 questions max)\r\n- Start with easy/engaging questions to build momentum\r\n- Use rating scales (1-5 or 1-10) for quantitative feedback\r\n- Include at least one open-ended question for qualitative insights\r\n- Group related questions into themed sections\r\n- Make most questions optional to improve completion rates\r\n- End with a thank you display step\r\n\r\nRecommended sections: Introduction, Rating Questions, Open Feedback, Demographics (optional)`,\r\n\r\n      intake: `\r\nDOMAIN: INTAKE WORKFLOWS (Client intake, patient intake, consultations)\r\nBest practices:\r\n- Collect demographics first (name, contact, DOB)\r\n- Include emergency contact information where relevant\r\n- Ask about relevant history (medical, financial, legal)\r\n- Capture current situation, goals, and concerns\r\n- Include consent/privacy acknowledgments\r\n- Use conditional logic for follow-up questions based on initial answers\r\n- Allow file uploads for prior records\r\n\r\nRecommended sections: Personal Information, Contact Details, History, Current Situation, Goals, Consent`,\r\n\r\n      onboarding: `\r\nDOMAIN: ONBOARDING WORKFLOWS (Employee, customer, vendor onboarding)\r\nBest practices:\r\n- Start with identity verification (name, email, ID)\r\n- Include tax and payment information sections where needed\r\n- Add policy acknowledgments and agreements\r\n- Include equipment/resource requests for employees\r\n- Use checkboxes for multi-item acknowledgments\r\n- End with next steps or welcome information\r\n- Track completion status with required fields\r\n\r\nRecommended sections: Personal Details, Employment/Account Info, Tax/Payment, Policies, Equipment, Completion`,\r\n\r\n      request: `\r\nDOMAIN: REQUEST WORKFLOWS (IT requests, PTO, expense, support tickets)\r\nBest practices:\r\n- Capture requester information upfront\r\n- Use radio buttons for request type/category\r\n- Include priority/urgency selection\r\n- Add date fields for requested date, due date\r\n- Use conditional sections based on request type\r\n- Include approval workflow triggers\r\n- Allow file attachments for supporting docs\r\n\r\nRecommended sections: Requester Info, Request Details, Justification, Attachments, Approval`,\r\n\r\n      checklist: `\r\nDOMAIN: CHECKLIST WORKFLOWS (Compliance, inspections, audits)\r\nBest practices:\r\n- Use yes_no or radio for pass/fail items\r\n- Group items by category or area\r\n- Include date fields for inspection date\r\n- Add signature fields for sign-off\r\n- Use required fields for critical items\r\n- Include comment fields for notes on non-compliant items\r\n- Consider numeric fields for measurements\r\n\r\nRecommended sections: General Info, Inspection Items by Category, Notes, Certification`,\r\n\r\n      general: `\r\nDOMAIN: GENERAL WORKFLOW\r\nFollow standard best practices for form design:\r\n- Organize into logical sections\r\n- Use appropriate field types\r\n- Keep questions clear and concise\r\n- Mark important fields as required`,\r\n    };\r\n\r\n    return guidance[category] || guidance.general;\r\n  }\r\n\r\n  /**\r\n   * Get domain-specific examples for a workflow category\r\n   */\r\n  public getCategoryExamples(category: WorkflowCategory): string {\r\n    const examples: Record<WorkflowCategory, string> = {\r\n      application: `\r\nEXAMPLE FIELDS for Applications:\r\n- fullName (short_text, required) - \"What is your full legal name?\"\r\n- emailAddress (email, required) - \"What is your email address?\"\r\n- phoneNumber (phone, required) - \"What is your phone number?\"\r\n- dateOfBirth (date, required) - \"What is your date of birth?\"\r\n- currentAddress (address, required) - \"What is your current address?\"\r\n- employmentStatus (radio, required) - \"What is your current employment status?\" [Employed, Self-employed, Unemployed, Student, Retired]\r\n- resumeUpload (file_upload) - \"Please upload your resume\"\r\n- availableStartDate (date) - \"When are you available to start?\"\r\n- certifyInformation (yes_no, required) - \"I certify that all information provided is accurate and complete\"`,\r\n\r\n      survey: `\r\nEXAMPLE FIELDS for Surveys:\r\n- overallSatisfaction (scale, required) - \"How satisfied are you overall?\" [1-5 scale]\r\n- recommendationLikelihood (scale, required) - \"How likely are you to recommend us?\" [1-10 NPS]\r\n- bestFeature (radio) - \"What did you like most?\" [Product Quality, Customer Service, Price, Convenience]\r\n- improvementAreas (multiple_choice) - \"What areas need improvement?\" [Speed, Quality, Communication, Pricing, Other]\r\n- additionalComments (long_text) - \"Any additional comments or suggestions?\"\r\n- contactForFollowup (yes_no) - \"May we contact you for follow-up?\"`,\r\n\r\n      intake: `\r\nEXAMPLE FIELDS for Intake:\r\n- firstName (short_text, required) - \"What is your first name?\"\r\n- lastName (short_text, required) - \"What is your last name?\"\r\n- dateOfBirth (date, required) - \"What is your date of birth?\"\r\n- insuranceProvider (short_text) - \"What is your insurance provider?\"\r\n- insurancePolicyNumber (short_text) - \"What is your policy number?\"\r\n- primaryConcern (long_text, required) - \"What is your primary concern today?\"\r\n- currentMedications (long_text) - \"List any current medications\"\r\n- emergencyContactName (short_text, required) - \"Emergency contact name\"\r\n- emergencyContactPhone (phone, required) - \"Emergency contact phone\"\r\n- privacyConsent (yes_no, required) - \"I consent to the privacy policy\"`,\r\n\r\n      onboarding: `\r\nEXAMPLE FIELDS for Onboarding:\r\n- legalFullName (short_text, required) - \"What is your full legal name?\"\r\n- preferredName (short_text) - \"What name do you prefer to go by?\"\r\n- personalEmail (email, required) - \"What is your personal email?\"\r\n- workEmail (email) - \"What is your work email?\"\r\n- startDate (date, required) - \"What is your start date?\"\r\n- socialSecurityNumber (short_text, required) - \"What is your Social Security Number?\"\r\n- bankAccountNumber (short_text) - \"Bank account for direct deposit\"\r\n- bankRoutingNumber (short_text) - \"Bank routing number\"\r\n- equipmentNeeded (multiple_choice) - \"What equipment do you need?\" [Laptop, Monitor, Keyboard, Mouse, Headset]\r\n- acknowledgeHandbook (yes_no, required) - \"I acknowledge receipt of the employee handbook\"\r\n- signatureBlock (signature_block, required) - \"Signature\"`,\r\n\r\n      request: `\r\nEXAMPLE FIELDS for Requests:\r\n- requesterName (short_text, required) - \"Your name\"\r\n- requesterEmail (email, required) - \"Your email\"\r\n- requestType (radio, required) - \"Type of request\" [IT Support, Equipment, Access, PTO, Expense]\r\n- priority (radio, required) - \"Priority level\" [Low, Medium, High, Urgent]\r\n- requestDescription (long_text, required) - \"Describe your request\"\r\n- requestedDate (date) - \"When do you need this?\"\r\n- justification (long_text) - \"Business justification\"\r\n- supportingDocuments (file_upload) - \"Attach any supporting documents\"\r\n- managerApproval (yes_no) - \"Manager pre-approved?\"`,\r\n\r\n      checklist: `\r\nEXAMPLE FIELDS for Checklists:\r\n- inspectorName (short_text, required) - \"Inspector name\"\r\n- inspectionDate (date, required) - \"Inspection date\"\r\n- location (short_text, required) - \"Location/area inspected\"\r\n- item1Compliant (yes_no, required) - \"Fire extinguisher present and inspected?\"\r\n- item2Compliant (yes_no, required) - \"Emergency exits clear and marked?\"\r\n- item3Compliant (yes_no, required) - \"First aid kit stocked and accessible?\"\r\n- nonComplianceNotes (long_text) - \"Notes on any non-compliant items\"\r\n- correctiveActionRequired (yes_no) - \"Is corrective action required?\"\r\n- inspectorSignature (signature_block, required) - \"Inspector signature\"`,\r\n\r\n      general: '',\r\n    };\r\n\r\n    return examples[category] || '';\r\n  }\r\n\r\n  /**\r\n   * Build the prompt for workflow generation\r\n   */\r\n  buildWorkflowGenerationPrompt(request: AIWorkflowGenerationRequest): string {\r\n    const constraints = request.constraints || {};\r\n    const maxSections = constraints.maxSections || 10;\r\n    const maxStepsPerSection = constraints.maxStepsPerSection || 10;\r\n    const category = request.category || 'general';\r\n    const categoryGuidance = this.getCategoryGuidance(category);\r\n    const categoryExamples = this.getCategoryExamples(category);\r\n\r\n    return `You are an expert workflow designer for ezBuildr, a professional document automation and workflow platform.\r\nYour task is to design a HIGH-QUALITY, PRODUCTION-READY workflow based on the user's description.\r\n${categoryGuidance}\r\n\r\nUser Description:\r\n${request.description}\r\n${categoryExamples ? `\\n${categoryExamples}` : ''}\r\n${request.placeholders ? `\\nTemplate Placeholders Available:\\n${request.placeholders.join(', ')}\\n` : ''}\r\n\r\nQUALITY REQUIREMENTS:\r\n1. **Logical Flow**: Questions should follow a natural, intuitive order\r\n2. **Clear Language**: Use professional, unambiguous language\r\n3. **Appropriate Granularity**: Break complex inputs into manageable steps\r\n4. **User Experience**: Minimize cognitive load, group related questions\r\n5. **Data Quality**: Use appropriate validation and input types\r\n6. **Completeness**: Capture ALL necessary information for the use case\r\n\r\nOutput a JSON object with this exact structure:\r\n{\r\n  \"title\": \"Workflow Title\",\r\n  \"description\": \"Brief description\",\r\n  \"sections\": [\r\n    {\r\n      \"id\": \"unique_section_id\",\r\n      \"title\": \"Section Title\",\r\n      \"description\": \"Optional description\",\r\n      \"order\": 0,\r\n      \"steps\": [\r\n        {\r\n          \"id\": \"unique_step_id\",\r\n          \"type\": \"short_text|long_text|multiple_choice|radio|checkbox|yes_no|date_time|file_upload\",\r\n          \"title\": \"Question or field title\",\r\n          \"description\": \"Optional description\",\r\n          \"alias\": \"camelCaseVariableName\",\r\n          \"required\": true|false,\r\n          \"config\": {}\r\n        }\r\n      ]\r\n    }\r\n  ],\r\n  \"logicRules\": [\r\n    {\r\n      \"id\": \"unique_rule_id\",\r\n      \"conditionStepAlias\": \"stepVariableName\",\r\n      \"operator\": \"equals|not_equals|contains|greater_than|less_than|is_empty|is_not_empty\",\r\n      \"conditionValue\": \"value to compare\",\r\n      \"targetType\": \"section|step\",\r\n      \"targetAlias\": \"targetVariableName\",\r\n      \"action\": \"show|hide|require|make_optional|skip_to\",\r\n      \"description\": \"What this rule does\"\r\n    }\r\n  ],\r\n  \"transformBlocks\": [\r\n    {\r\n      \"id\": \"unique_block_id\",\r\n      \"name\": \"Block Name\",\r\n      \"language\": \"javascript|python\",\r\n      \"code\": \"code to execute\",\r\n      \"inputKeys\": [\"alias1\", \"alias2\"],\r\n      \"outputKey\": \"outputAlias\",\r\n      \"phase\": \"onSectionSubmit|onWorkflowComplete\",\r\n      \"timeoutMs\": 1000\r\n    }\r\n  ],\r\n  \"notes\": \"Optional notes about design decisions\"\r\n}\r\n\r\nCRITICAL CONSTRAINTS:\r\n- Maximum ${maxSections} sections\r\n- Maximum ${maxStepsPerSection} steps per section\r\n- All step aliases MUST be unique across the workflow and use camelCase (e.g., \"firstName\", \"emailAddress\")\r\n- ALWAYS generate a descriptive, meaningful alias for EVERY step - NEVER leave empty\r\n- All IDs must be unique and use lowercase_with_underscores format\r\n- Step titles must be clear questions or instructions (e.g., \"What is your full name?\" not \"Name\")\r\n- For multiple_choice, radio types, ALWAYS include config.options as array of strings (minimum 2 options)\r\n- Transform block code MUST call emit(value) exactly once\r\n- NO network calls or file system access in transform blocks\r\n\r\nSTEP TYPE SELECTION GUIDE:\r\n- **short_text**: Names, titles, single-line answers (< 100 chars)\r\n- **long_text**: Descriptions, explanations, comments (> 100 chars)\r\n- **email**: Email addresses (use this instead of short_text for emails)\r\n- **phone**: Phone numbers with formatting\r\n- **number**: Numeric values, quantities, counts\r\n- **currency**: Money amounts (auto-formats with $ symbol)\r\n- **date**: Date selection without time\r\n- **date_time**: Date with time selection\r\n- **radio**: Single selection from 2-7 options (mutually exclusive)\r\n- **multiple_choice**: Multi-select from 2-10 options (checkboxes)\r\n- **yes_no**: Simple binary choice\r\n- **scale**: Rating or scale (1-5, 1-10, etc.)\r\n- **address**: Full mailing address\r\n- **website**: URLs with validation\r\n- **file_upload**: Document or image uploads\r\n- **display**: Information-only, no input required\r\n\r\nBEST PRACTICES:\r\n1. Group related questions into logical sections (e.g., \"Personal Information\", \"Contact Details\")\r\n2. Start with basic identifying information before complex questions\r\n3. Use appropriate field types for better validation (email vs short_text, phone vs short_text)\r\n4. Provide clear, actionable descriptions for complex questions\r\n5. Use logic rules to show/hide conditional questions based on previous answers\r\n6. Keep sections focused - don't mix unrelated topics\r\n7. Use transform blocks for calculated fields (full name from first+last, total from sum, etc.)\r\n\r\nLOGIC RULES GUIDANCE:\r\n- Use show/hide for optional sections based on answers\r\n- Use require/make_optional for conditional required fields\r\n- Use skip_to for branching workflows\r\n- Keep conditions simple: prefer equals/not_equals over complex operators\r\n\r\nTRANSFORM BLOCK PATTERNS:\r\n- Concatenation: \\`emit(input.firstName + ' ' + input.lastName);\\`\r\n- Calculations: \\`emit(input.quantity * input.price);\\`\r\n- Formatting: \\`emit(input.rawValue.toUpperCase());\\`\r\n- Date math: Use helpers.date methods for date calculations\r\n\r\nOutput ONLY valid JSON, NO markdown code blocks, NO additional text.`;\r\n  }\r\n\r\n  /**\r\n   * Build the prompt for workflow suggestions\r\n   */\r\n  buildWorkflowSuggestionPrompt(\r\n    request: AIWorkflowSuggestionRequest,\r\n    existingWorkflow: any,\r\n  ): string {\r\n    return `You are a workflow improvement assistant for ezBuildr.\r\nYou are reviewing an existing workflow and suggesting improvements based on user request.\r\n\r\nUser Request:\r\n${request.description}\r\n\r\nExisting Workflow:\r\n${JSON.stringify(existingWorkflow, null, 2)}\r\n\r\nOutput a JSON object with this exact structure:\r\n{\r\n  \"newSections\": [ /* array of new sections to add, same schema as workflow generation */ ],\r\n  \"newLogicRules\": [ /* array of new logic rules, same schema as workflow generation */ ],\r\n  \"newTransformBlocks\": [ /* array of new transform blocks, same schema as workflow generation */ ],\r\n  \"modifications\": [\r\n    {\r\n      \"type\": \"section|step|logic_rule|transform_block\",\r\n      \"id\": \"existing_item_id\",\r\n      \"changes\": { \"field\": \"newValue\" },\r\n      \"reason\": \"Why this change is suggested\"\r\n    }\r\n  ],\r\n  \"notes\": \"Additional context about the suggestions\"\r\n}\r\n\r\nGuidelines:\r\n- Suggest additions and modifications separately\r\n- Only suggest changes that align with the user's request\r\n- Reuse existing step aliases when referencing them in new logic rules\r\n- Maintain consistency with existing workflow structure\r\n- Keep suggestions practical and implementable\r\n- For new elements, follow the same schema and constraints as workflow generation\r\n\r\nOutput ONLY the JSON object, no additional text or markdown.`;\r\n  }\r\n\r\n  /**\r\n   * Build the prompt for binding suggestions\r\n   */\r\n  buildBindingSuggestionPrompt(\r\n    variables: Array<{ alias: string; label: string; type: string }>,\r\n    placeholders: string[],\r\n  ): string {\r\n    return `You are a template binding assistant for ezBuildr.\r\nYour task is to match DOCX template placeholders to workflow variables.\r\n\r\nAvailable Workflow Variables:\r\n${variables.map((v) => `- ${v.alias} (${v.type}): ${v.label}`).join('\\n')}\r\n\r\nTemplate Placeholders to Match:\r\n${placeholders.map((p) => `- {{${p}}}`).join('\\n')}\r\n\r\nOutput a JSON object with this exact structure:\r\n{\r\n  \"suggestions\": [\r\n    {\r\n      \"placeholder\": \"placeholder_name\",\r\n      \"variable\": \"workflowVariableAlias\",\r\n      \"confidence\": 0.95,\r\n      \"rationale\": \"Why this binding makes sense\"\r\n    }\r\n  ],\r\n  \"unmatchedPlaceholders\": [\"placeholder1\", \"placeholder2\"],\r\n  \"unmatchedVariables\": [\"variable1\", \"variable2\"]\r\n}\r\n\r\nGuidelines:\r\n- Match placeholders to variables based on semantic similarity\r\n- Confidence should be 0-1, where 1.0 is perfect match\r\n- Only suggest matches with confidence >= 0.5\r\n- Consider both the variable alias and label when matching\r\n- Placeholders and variables that don't have a good match go in unmatched arrays\r\n- Provide clear rationale for each suggestion\r\n\r\nOutput ONLY the JSON object, no additional text or markdown.`;\r\n  }\r\n\r\n  /**\r\n   * Build prompt for value suggestion\r\n   */\r\n  buildValueSuggestionPrompt(\r\n    steps: Array<{\r\n      key: string;\r\n      type: string;\r\n      label?: string;\r\n      options?: string[];\r\n      description?: string;\r\n    }>,\r\n    mode: 'full' | 'partial',\r\n  ): string {\r\n    const stepDescriptions = steps\r\n      .map((step) => {\r\n        let desc = `- ${step.key} (${step.type})`;\r\n        if (step.label) { desc += `: ${step.label}`; }\r\n        if (step.description) { desc += ` - ${step.description}`; }\r\n        if (step.options && step.options.length > 0) {\r\n          desc += ` [Options: ${step.options.join(', ')}]`;\r\n        }\r\n        return desc;\r\n      })\r\n      .join('\\n');\r\n\r\n    return `You are a test data generator. Generate realistic, plausible values for the following workflow fields.\r\n\r\nFields to populate:\r\n${stepDescriptions}\r\n\r\nRequirements:\r\n- Generate realistic values that make sense for each field type\r\n- For text fields, use natural language appropriate to the label\r\n- For radio/checkbox/select fields, choose from the provided options only\r\n- For yes_no fields, return boolean true or false\r\n- For date_time fields, return ISO 8601 date-time strings\r\n- For number fields, return numeric values\r\n- Make the data cohesive and realistic (e.g., if there's firstName and lastName, make them match a person)\r\n- ${mode === 'full' ? 'Generate values for ALL fields' : 'Generate values only for the fields listed'}\r\n\r\nReturn ONLY a JSON object with this structure:\r\n{\r\n  \"values\": {\r\n    \"key1\": \"value1\",\r\n    \"key2\": \"value2\",\r\n    ...\r\n  }\r\n}\r\n\r\nDo not include any markdown formatting, code blocks, or additional text. Return raw JSON only.`;\r\n  }\r\n\r\n  /**\r\n   * Build prompt for workflow revision\r\n   */\r\n  buildWorkflowRevisionPrompt(request: AIWorkflowRevisionRequest): string {\r\n    return `You are a ezBuildr Workflow Revision Engine.\r\nYour task is to modify the Current Workflow based on the User Instruction and Conversation History.\r\n\r\nCurrent Workflow JSON:\r\n${JSON.stringify(request.currentWorkflow, null, 2)}\r\n\r\nUser Instruction: \"${request.userInstruction}\"\r\n\r\nConversation History:\r\n${request.conversationHistory ? request.conversationHistory.map((m) => `${m.role.toUpperCase()}: ${m.content}`).join('\\n') : 'None'}\r\n\r\nMode: ${request.mode} (Respect constraints of this mode)\r\n\r\nOutput a JSON object with this exact structure:\r\n{\r\n  \"updatedWorkflow\": {\r\n    \"title\": \"Workflow Title\",\r\n    \"description\": \"Description\",\r\n    \"sections\": [\r\n      {\r\n        \"id\": \"section-1\",\r\n        \"title\": \"Section Title\",\r\n        \"description\": null,\r\n        \"order\": 0,\r\n        \"steps\": [\r\n          {\r\n            \"id\": \"step-1\",\r\n            \"type\": \"short_text\",\r\n            \"title\": \"What is your name?\",  // REQUIRED - question text\r\n            \"description\": null,\r\n            \"alias\": \"name\",\r\n            \"required\": true,\r\n            \"config\": {}\r\n          }\r\n        ]\r\n      }\r\n    ],\r\n    \"logicRules\": [\r\n      {\r\n        \"id\": \"rule-1\",\r\n        \"conditionStepAlias\": \"step_alias\",  // REQUIRED - alias of step to check\r\n        \"operator\": \"equals\",  // REQUIRED - use: equals, not_equals, contains, greater_than, less_than, is_empty, etc. (never use \"is\")\r\n        \"value\": \"some value\",  // Value to compare against\r\n        \"targetType\": \"step\",  // REQUIRED - \"step\" or \"section\"\r\n        \"targetAlias\": \"other_step\",  // REQUIRED - alias of step/section to affect\r\n        \"action\": \"show\",  // REQUIRED - \"show\", \"hide\", \"require\", \"make_optional\", or \"skip_to\"\r\n        \"description\": \"Show other_step if step_alias equals 'some value'\"\r\n      }\r\n    ],\r\n    \"transformBlocks\": [],\r\n    \"notes\": null\r\n  },\r\n  \"diff\": {\r\n    \"changes\": [\r\n      {\r\n        \"type\": \"add|remove|update|move\",\r\n        \"target\": \"path.to.element\",\r\n        \"before\": null,\r\n        \"after\": { ... },\r\n        \"explanation\": \"Added a new specific question\"\r\n      }\r\n    ]\r\n  },\r\n  \"explanation\": [\"Point 1 about what changed\", \"Point 2\"],\r\n  \"suggestions\": [\"Follow-up suggestion 1\"]\r\n}\r\n\r\nCRITICAL REQUIREMENTS:\r\n    1. **FULL RESPONSE REQUIRED**: You MUST return the ENTIRE workflow structure in 'updatedWorkflow', including ALL existing sections and steps that you did not change.\r\n    2. **DELETION WARNING**: Any section or step that is missing from your 'updatedWorkflow' will be PERMANENTLY DELETED. Do not be lazy.\r\n    3. **TITLES**: Every step MUST have a \"title\" field.\r\n    4. **IDS**: Preserve existing IDs. Generate new UUIDs for new items.\r\n    5. **CONTENT GENERATION**: If the User Instruction asks to \"build\", \"create\", or \"automate\" a form/workflow, and the current workflow has few or no questions, you MUST generate the full structure (multiple sections, relevant questions). DO NOT just update the title. YOU MUST BUILD THE CONTENT.\r\n    6. **ALIASES**: Every step MUST have a unique \"alias\" in camelCase (e.g., \"firstName\", \"driverLicenseNumber\"). Do not leave it null or empty.\r\n\r\n    Valid Step Types:\r\n    - Text: \"short_text\", \"long_text\", \"email\", \"phone\", \"website\", \"number\", \"currency\"\r\n    - Choice: \"radio\", \"multiple_choice\", \"yes_no\"\r\n    - Date: \"date\", \"time\", \"date_time\"\r\n    - Other: \"scale\", \"address\", \"file_upload\", \"display\", \"signature_block\"\r\n\r\n    Output ONLY the JSON object.`;\r\n  }\r\n\r\n  /**\r\n   * Build prompt for logic generation\r\n   */\r\n  buildLogicGenerationPrompt(request: AIConnectLogicRequest): string {\r\n    return `You are a Logic Architect for ezBuildr.\r\nTask: Generate logical conditions (logicRules) to connect steps based on the user's description.\r\nWorkflow Context:\r\n${JSON.stringify(request.currentWorkflow, null, 2)}\r\nUser Request: \"${request.description}\"\r\n\r\nOutput JSON exactly matching AIConnectLogicResponse schema:\r\n{\r\n  \"updatedWorkflow\": { ... },\r\n  \"diff\": { \"changes\": [...] },\r\n  \"explanation\": [\"...\"],\r\n  \"suggestions\": [\"...\"]\r\n}\r\nOnly return JSON.`;\r\n  }\r\n\r\n  /**\r\n   * Build prompt for logic debugging\r\n   */\r\n  buildLogicDebugPrompt(request: AIDebugLogicRequest): string {\r\n    return `Analyze this workflow's logic for infinite loops, contradictions, or unreachable branches.\r\nWorkflow: ${JSON.stringify(request.currentWorkflow, null, 2)}\r\nOutput JSON matching AIDebugLogicResponse.`;\r\n  }\r\n\r\n  /**\r\n   * Build prompt for logic visualization\r\n   */\r\n  buildLogicVisualizationPrompt(request: AIVisualizeLogicRequest): string {\r\n    return `Generate a node-edge graph representation of this workflow's logic flow.\r\nWorkflow: ${JSON.stringify(request.currentWorkflow, null, 2)}\r\nOutput JSON matching AIVisualizeLogicResponse with \"graph\": { \"nodes\": [], \"edges\": [] }.`;\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const aiPromptBuilder = new AIPromptBuilder();\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\AIProviderClient.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":35,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1187,1190],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1187,1190],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":36,"column":23,"nodeType":"Property","messageId":"anyAssignment","endLine":36,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":36,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":36,"endColumn":43},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 33 to the 15 allowed.","line":41,"column":9,"nodeType":null,"messageId":"refactorFunction","endLine":41,"endColumn":16},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":53,"column":23,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":53,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1796,1817],"text":"(this.config.maxTokens != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[1796,1817],"text":"(this.config.maxTokens ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1796,1817],"text":"(Boolean(this.config.maxTokens))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":53,"column":45,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":53,"endColumn":47,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[1818,1820],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":91,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2943,2946],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2943,2946],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":97,"column":28,"nodeType":"Identifier","messageId":"conditionErrorNumber","endLine":97,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[3157,3169],"text":"(retryAfterMs !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[3157,3169],"text":"(!Number.isNaN(retryAfterMs))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3157,3169],"text":"(Boolean(retryAfterMs))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"max-depth","severity":2,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":99,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":104,"endColumn":14},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":122,"column":15,"nodeType":"Property","messageId":"anyAssignment","endLine":122,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":122,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":122,"endColumn":43},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":122,"column":64,"nodeType":"Identifier","messageId":"conditionErrorNumber","endLine":122,"endColumn":76,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[4103,4115],"text":"(retryAfterMs !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[4103,4115],"text":"(!Number.isNaN(retryAfterMs))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4103,4115],"text":"(Boolean(retryAfterMs))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":124,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNumber","endLine":124,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[4189,4201],"text":"(retryAfterMs !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[4189,4201],"text":"(!Number.isNaN(retryAfterMs))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4189,4201],"text":"(Boolean(retryAfterMs))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":148,"column":70,"nodeType":"Property","messageId":"anyAssignment","endLine":148,"endColumn":98},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":148,"column":91,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":148,"endColumn":98},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":159,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":159,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":159,"column":31,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":159,"endColumn":38}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * AI Provider Client\r\n *\r\n * Unified client that delegates to provider-specific implementations\r\n * Handles retry logic, rate limiting, and telemetry\r\n */\r\n\r\nimport { createLogger } from '../../logger';\r\n\r\nimport { AIError, isRateLimitError, isTimeoutError, getRetryAfter } from './AIError';\r\nimport { estimateTokenCount } from './AIServiceUtils';\r\nimport { ModelRegistry } from './ModelRegistry';\r\nimport { ProviderFactory } from './providers/ProviderFactory';\r\n\r\nimport type { IAIProvider } from './providers/types';\r\nimport type { TaskType } from './types';\r\nimport type { AIProviderConfig } from '../../../shared/types/ai';\r\n\r\nconst logger = createLogger({ module: 'ai-provider-client' });\r\n\r\n/**\r\n * AI Provider Client - handles all LLM API calls with retry logic and telemetry\r\n */\r\nexport class AIProviderClient {\r\n  private provider: IAIProvider | null = null;\r\n  private config: AIProviderConfig;\r\n\r\n  constructor(config: AIProviderConfig) {\r\n    this.config = config;\r\n\r\n    // Only create provider if we have a valid config\r\n    if (config.provider && config.apiKey) {\r\n      try {\r\n        this.provider = ProviderFactory.createProvider(config);\r\n      } catch (error: any) {\r\n        logger.warn({ error: error.message, config: { provider: config.provider } }, 'Failed to create provider');\r\n      }\r\n    }\r\n  }\r\n\r\n  async callLLM(prompt: string, taskType: TaskType, systemMessage?: string): Promise<string> {\r\n    if (!this.provider) {\r\n      throw new AIError('AI provider not initialized', 'API_ERROR', {\r\n        config: { provider: this.config.provider }\r\n      });\r\n    }\r\n\r\n    const { provider, model } = this.config;\r\n    const startTime = Date.now();\r\n    const promptTokens = estimateTokenCount(prompt);\r\n\r\n    // Get task-specific max tokens\r\n    const maxTokens = this.config.maxTokens || ModelRegistry.getTaskMaxTokens(taskType);\r\n\r\n    // Telemetry: Track AI request\r\n    logger.info({\r\n      event: 'ai_request_started',\r\n      provider,\r\n      model,\r\n      taskType,\r\n      promptTokens,\r\n      maxTokens,\r\n    }, 'AI request started');\r\n\r\n    const maxRetries = 6;\r\n    let attempt = 0;\r\n\r\n    while (attempt <= maxRetries) {\r\n      try {\r\n        // Delegate to provider\r\n        const response = await this.provider.generateResponse(prompt, taskType, systemMessage);\r\n\r\n        // Telemetry: Track success\r\n        const responseTokens = estimateTokenCount(response);\r\n        const duration = Date.now() - startTime;\r\n        const cost = ModelRegistry.estimateCost(provider, model, promptTokens, responseTokens);\r\n\r\n        logger.info({\r\n          event: 'ai_request_success',\r\n          provider,\r\n          model,\r\n          taskType,\r\n          promptTokens,\r\n          responseTokens,\r\n          totalTokens: promptTokens + responseTokens,\r\n          durationMs: duration,\r\n          estimatedCostUSD: cost,\r\n        }, 'AI request succeeded');\r\n\r\n        return response;\r\n      } catch (error: any) {\r\n        // Handle rate limiting with retry\r\n        if (isRateLimitError(error)) {\r\n          const retryAfterMs = getRetryAfter(error);\r\n\r\n          if (attempt < maxRetries) {\r\n            const waitMs = retryAfterMs || (Math.pow(2, attempt) * 1000); // Exponential backoff\r\n\r\n            if (waitMs <= 60000) { // Max 60 second wait\r\n              logger.warn({ attempt, waitMs }, 'Rate limit hit, retrying...');\r\n              await new Promise(resolve => setTimeout(resolve, waitMs));\r\n              attempt++;\r\n              continue;\r\n            }\r\n          }\r\n\r\n          // Otherwise, throw rate limit error\r\n          const duration = Date.now() - startTime;\r\n          logger.error({\r\n            event: 'ai_request_failed',\r\n            provider,\r\n            model,\r\n            taskType,\r\n            errorType: 'RATE_LIMIT',\r\n            durationMs: duration,\r\n            attempts: attempt + 1,\r\n          }, 'AI request failed: rate limit');\r\n\r\n          throw new AIError(\r\n            'AI API rate limit exceeded. Please try again later.',\r\n            'RATE_LIMIT',\r\n            { originalError: error.message, retryAfterSeconds: retryAfterMs ? Math.ceil(retryAfterMs / 1000) : 60 },\r\n            true,\r\n            retryAfterMs ? Math.ceil(retryAfterMs / 1000) : 60\r\n          );\r\n        }\r\n\r\n        // Handle timeouts with retry\r\n        if (isTimeoutError(error)) {\r\n          if (attempt < maxRetries) {\r\n            logger.warn({ attempt }, 'Timeout, retrying...');\r\n            await new Promise(resolve => setTimeout(resolve, 1000));\r\n            attempt++;\r\n            continue;\r\n          }\r\n\r\n          const duration = Date.now() - startTime;\r\n          logger.error({\r\n            event: 'ai_request_failed',\r\n            provider,\r\n            model,\r\n            taskType,\r\n            errorType: 'TIMEOUT',\r\n            durationMs: duration,\r\n            attempts: attempt + 1,\r\n          }, 'AI request failed: timeout');\r\n\r\n          throw new AIError('AI API request timed out', 'TIMEOUT', { originalError: error.message }, true);\r\n        }\r\n\r\n        // Generic API error - no retry\r\n        const duration = Date.now() - startTime;\r\n        logger.error({\r\n          event: 'ai_request_failed',\r\n          provider,\r\n          model,\r\n          taskType,\r\n          errorType: 'API_ERROR',\r\n          errorMessage: error.message,\r\n          durationMs: duration,\r\n          attempts: attempt + 1,\r\n        }, 'AI request failed: API error');\r\n\r\n        throw AIError.fromUnknown(error, 'API_ERROR');\r\n      }\r\n    }\r\n\r\n    throw new Error('Unexpected retry loop exit');\r\n  }\r\n\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\AIServiceUtils.ts","messages":[{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":120,"column":44,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":120,"endColumn":46,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[3587,3589],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":121,"column":45,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":121,"endColumn":47,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[3647,3649],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":122,"column":46,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":122,"endColumn":48,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[3708,3710],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":123,"column":47,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":123,"endColumn":49,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[3770,3772],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `INVALID_RESPONSE` must match one of the following formats: camelCase","line":155,"column":5,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":155,"endColumn":21},{"ruleId":"sonarjs/no-duplicate-string","severity":2,"message":"Define a constant instead of duplicating this literal 5 times.","line":156,"column":7,"nodeType":"Literal","messageId":"defineConstant","endLine":156,"endColumn":34},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `VALIDATION_ERROR` must match one of the following formats: camelCase","line":165,"column":5,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":165,"endColumn":21},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `RATE_LIMIT` must match one of the following formats: camelCase","line":175,"column":5,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":175,"endColumn":15},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `TIMEOUT` must match one of the following formats: camelCase","line":185,"column":5,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":185,"endColumn":12},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `RESPONSE_TRUNCATED` must match one of the following formats: camelCase","line":197,"column":5,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":197,"endColumn":23},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `API_ERROR` must match one of the following formats: camelCase","line":205,"column":5,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":205,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":226,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":226,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7579,7582],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7579,7582],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":232,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7831,7834],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7831,7834],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .troubleshooting on an `any` value.","line":232,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":232,"endColumn":33},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":239,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":239,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7994,7997],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7994,7997],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":241,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":241,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":242,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":242,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":242,"column":19,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":242,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":242,"column":25,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":242,"endColumn":32},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":243,"column":9,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":243,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[8179,8184],"text":"Boolean(match)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":243,"column":46,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":243,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [1] on an `any` value.","line":243,"column":52,"nodeType":"Literal","messageId":"unsafeMemberExpression","endLine":243,"endColumn":53},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 24 to the 15 allowed.","line":264,"column":17,"nodeType":null,"messageId":"refactorFunction","endLine":264,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":362,"column":9,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":362,"endColumn":51},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":362,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":362,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12056,12059],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12056,12059],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `\"number\" | \"boolean\" | \"short_text\" | \"long_text\" | \"multiple_choice\" | \"radio\" | \"yes_no\" | \"date_time\" | \"file_upload\" | \"loop_group\" | \"computed\" | \"js_question\" | \"repeater\" | ... 24 more ... | \"display_advanced\"`.","line":367,"column":38,"nodeType":"TSAsExpression","messageId":"unsafeArgument","endLine":367,"endColumn":54},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":367,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":367,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12269,12272],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12269,12272],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":27,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * AI Service Utilities\r\n *\r\n * Token estimation, cost calculation, validation, and error handling utilities\r\n */\r\n\r\nimport { createLogger } from '../../logger';\r\n\r\nimport { AIError } from './AIError';\r\nimport { ModelRegistry } from './ModelRegistry';\r\n\r\nimport type { AIErrorCode } from './types';\r\nimport type { AIGeneratedWorkflow, AIProvider } from '../../../shared/types/ai';\r\n\r\nconst logger = createLogger({ module: 'ai-service-utils' });\r\n\r\n/**\r\n * Estimate token count from text (rough approximation: 1 token  4 characters)\r\n * This is a conservative estimate - actual tokenization may vary by model\r\n */\r\nexport function estimateTokenCount(text: string): number {\r\n  return Math.ceil(text.length / 4);\r\n}\r\n\r\n/**\r\n * Get maximum context window for a given provider/model\r\n * @deprecated Use ModelRegistry.getMaxContextTokens instead\r\n */\r\nexport function getMaxContextTokens(provider: string, model: string): number {\r\n  return ModelRegistry.getMaxContextTokens(provider as AIProvider, model);\r\n}\r\n\r\n/**\r\n * Validate that prompt + response won't exceed context window\r\n */\r\nexport function validateTokenLimits(\r\n  prompt: string,\r\n  maxResponseTokens: number,\r\n  provider: string,\r\n  model: string,\r\n): void {\r\n  const promptTokens = estimateTokenCount(prompt);\r\n  const maxContext = getMaxContextTokens(provider, model);\r\n  const totalTokens = promptTokens + maxResponseTokens;\r\n\r\n  logger.debug({\r\n    promptTokens,\r\n    maxResponseTokens,\r\n    totalTokens,\r\n    maxContext,\r\n    provider,\r\n    model,\r\n  }, 'Token usage estimate');\r\n\r\n  if (totalTokens > maxContext) {\r\n    const errorMsg = [\r\n      `Request exceeds model's context window:`,\r\n      `  Prompt: ~${promptTokens.toLocaleString()} tokens`,\r\n      `  Expected response: ~${maxResponseTokens.toLocaleString()} tokens`,\r\n      `  Total: ~${totalTokens.toLocaleString()} tokens`,\r\n      `  Model limit: ${maxContext.toLocaleString()} tokens`,\r\n      ``,\r\n      `The workflow or request is too large for the AI model to process.`,\r\n    ].join('\\n');\r\n\r\n    throw new AIError(errorMsg, 'VALIDATION_ERROR', {\r\n      promptTokens,\r\n      maxResponseTokens,\r\n      totalTokens,\r\n      maxContext,\r\n      provider,\r\n      model,\r\n    });\r\n  }\r\n\r\n  // Warn if we're using >80% of context window\r\n  const usagePercent = (totalTokens / maxContext) * 100;\r\n  if (usagePercent > 80) {\r\n    logger.warn({\r\n      promptTokens,\r\n      maxResponseTokens,\r\n      totalTokens,\r\n      maxContext,\r\n      usagePercent: usagePercent.toFixed(1),\r\n    }, 'High token usage - approaching context limit');\r\n  }\r\n}\r\n\r\n/**\r\n * Estimate cost in USD for AI API call\r\n * @deprecated Use ModelRegistry.estimateCost instead\r\n */\r\nexport function estimateCost(\r\n  provider: string,\r\n  model: string,\r\n  promptTokens: number,\r\n  responseTokens: number,\r\n): number {\r\n  return ModelRegistry.estimateCost(provider as AIProvider, model, promptTokens, responseTokens);\r\n}\r\n\r\n/**\r\n * Detect if JSON response appears truncated\r\n * Returns true if response looks incomplete\r\n */\r\nexport function isResponseTruncated(response: string): boolean {\r\n  const trimmed = response.trim();\r\n\r\n  // Check 1: Response should end with closing brace or bracket\r\n  const endsCorrectly = trimmed.endsWith('}') || trimmed.endsWith(']');\r\n  if (!endsCorrectly) {\r\n    logger.warn({\r\n      lastChar: trimmed.charAt(trimmed.length - 1),\r\n      last50: trimmed.substring(trimmed.length - 50),\r\n    }, 'Response does not end with closing brace/bracket');\r\n    return true;\r\n  }\r\n\r\n  // Check 2: Count opening vs closing braces\r\n  const openBraces = (trimmed.match(/\\{/g) || []).length;\r\n  const closeBraces = (trimmed.match(/\\}/g) || []).length;\r\n  const openBrackets = (trimmed.match(/\\[/g) || []).length;\r\n  const closeBrackets = (trimmed.match(/\\]/g) || []).length;\r\n\r\n  if (openBraces !== closeBraces || openBrackets !== closeBrackets) {\r\n    logger.warn({\r\n      openBraces,\r\n      closeBraces,\r\n      openBrackets,\r\n      closeBrackets,\r\n    }, 'Mismatched braces/brackets detected');\r\n    return true;\r\n  }\r\n\r\n  // Check 3: Try to parse as JSON\r\n  // If it parses successfully, it's definitely not truncated\r\n  try {\r\n    JSON.parse(trimmed);\r\n    return false;  // Parsing succeeded = not truncated\r\n  } catch (parseError) {\r\n    // Parsing failed - likely truncated\r\n    logger.warn({\r\n      parseError: parseError instanceof Error ? parseError.message : String(parseError),\r\n      last100: trimmed.substring(Math.max(0, trimmed.length - 100)),\r\n    }, 'JSON parsing failed - response appears truncated');\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Get troubleshooting hints for error codes\r\n */\r\nexport function getTroubleshootingHints(code: string): string {\r\n  const hints: Record<string, string> = {\r\n    INVALID_RESPONSE: [\r\n      ' Troubleshooting Steps:',\r\n      '1. The AI model returned malformed JSON. This usually happens when:',\r\n      '   - The model is overloaded or experiencing issues',\r\n      '   - The prompt is too complex or large',\r\n      '2. Try again in a few moments',\r\n      '3. If the issue persists, try simplifying your request',\r\n      '4. Check AI provider status: https://status.openai.com or https://status.anthropic.com',\r\n    ].join('\\n'),\r\n\r\n    VALIDATION_ERROR: [\r\n      ' Troubleshooting Steps:',\r\n      '1. The AI response structure doesn\\'t match our expected format',\r\n      '2. This may indicate:',\r\n      '   - A breaking change in the AI model behavior',\r\n      '   - The model is struggling with the complexity of the request',\r\n      '3. Try simplifying your workflow or request',\r\n      '4. If this persists, please report this issue with the workflow details',\r\n    ].join('\\n'),\r\n\r\n    RATE_LIMIT: [\r\n      ' Troubleshooting Steps:',\r\n      '1. You\\'ve hit the AI provider\\'s rate limit',\r\n      '2. Solutions:',\r\n      '   - Wait 60 seconds and try again',\r\n      '   - Check your API key quota at your provider\\'s dashboard',\r\n      '   - Consider upgrading your API plan for higher limits',\r\n      '   - If using free tier, you may need to wait until limits reset',\r\n    ].join('\\n'),\r\n\r\n    TIMEOUT: [\r\n      ' Troubleshooting Steps:',\r\n      '1. The AI request took too long (>10 minutes)',\r\n      '2. This usually happens when:',\r\n      '   - Your workflow is very large or complex',\r\n      '   - The AI provider is experiencing slowdowns',\r\n      '3. Try:',\r\n      '   - Simplifying your request',\r\n      '   - Breaking large workflows into smaller chunks',\r\n      '   - Trying again during off-peak hours',\r\n    ].join('\\n'),\r\n\r\n    RESPONSE_TRUNCATED: [\r\n      ' Auto-Recovery Active:',\r\n      '1. The AI response was too large and got truncated',\r\n      '2. The system automatically detected this and will retry with chunking',\r\n      '3. This may take a bit longer but will handle larger workflows',\r\n      '4. No action needed - the system is recovering automatically',\r\n    ].join('\\n'),\r\n\r\n    API_ERROR: [\r\n      ' Troubleshooting Steps:',\r\n      '1. Check your API key is valid and has proper permissions',\r\n      '2. Verify your API key environment variable:',\r\n      `   - GEMINI_API_KEY or AI_API_KEY is set correctly`,\r\n      '3. Check your API quota/billing status',\r\n      '4. Test your API key at the provider\\'s dashboard',\r\n      '5. If using a proxy, verify network connectivity',\r\n    ].join('\\n'),\r\n  };\r\n\r\n  return hints[code] || '';\r\n}\r\n\r\n/**\r\n * Create a typed error with troubleshooting hints\r\n * @deprecated Use AIError class directly or import createAIError from AIError.ts\r\n */\r\nexport function createAIError(\r\n  message: string,\r\n  code: AIErrorCode,\r\n  details?: any,\r\n): AIError {\r\n  const troubleshootingHints = getTroubleshootingHints(code);\r\n  const fullMessage = troubleshootingHints ? `${message}\\n\\n${troubleshootingHints}` : message;\r\n\r\n  const error = new AIError(fullMessage, code, details);\r\n  (error as any).troubleshooting = troubleshootingHints;\r\n  return error;\r\n}\r\n\r\n/**\r\n * Extract retry delay from error if available\r\n */\r\nexport function getRetryAfter(error: any): number | null {\r\n  // Check for Google's \"Please retry in X s\"\r\n  if (typeof error.message === 'string') {\r\n    const match = error.message.match(/retry in ([0-9.]+)s/);\r\n    if (match) { return Math.ceil(parseFloat(match[1]) * 1000); }\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Strip markdown code blocks from AI response\r\n */\r\nexport function stripMarkdownCodeBlocks(text: string): string {\r\n  let stripped = text.trim();\r\n  if (stripped.startsWith('```json')) {\r\n    stripped = stripped.replace(/^```json\\n/, '').replace(/\\n```$/, '');\r\n  } else if (stripped.startsWith('```')) {\r\n    stripped = stripped.replace(/^```\\n/, '').replace(/\\n```$/, '');\r\n  }\r\n  return stripped;\r\n}\r\n\r\n/**\r\n * Validate workflow structure (unique IDs, etc)\r\n */\r\nexport function validateWorkflowStructure(workflow: AIGeneratedWorkflow): void {\r\n  // Check for unique section IDs\r\n  const sectionIds = workflow.sections.map((s) => s.id);\r\n  const uniqueSectionIds = new Set(sectionIds);\r\n  if (sectionIds.length !== uniqueSectionIds.size) {\r\n    throw createAIError(\r\n      'Duplicate section IDs found in generated workflow',\r\n      'VALIDATION_ERROR',\r\n    );\r\n  }\r\n\r\n  // Check for unique step IDs and aliases across all sections\r\n  const stepIds = new Set<string>();\r\n  const stepAliases = new Set<string>();\r\n\r\n  for (const section of workflow.sections) {\r\n    for (const step of section.steps) {\r\n      if (stepIds.has(step.id)) {\r\n        throw createAIError(\r\n          `Duplicate step ID: ${step.id}`,\r\n          'VALIDATION_ERROR',\r\n        );\r\n      }\r\n      stepIds.add(step.id);\r\n\r\n      if (step.alias) {\r\n        if (stepAliases.has(step.alias)) {\r\n          throw createAIError(\r\n            `Duplicate step alias: ${step.alias}`,\r\n            'VALIDATION_ERROR',\r\n          );\r\n        }\r\n        stepAliases.add(step.alias);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Validate logic rules reference existing steps/sections\r\n  for (const rule of workflow.logicRules) {\r\n    if (rule.conditionStepAlias && !stepAliases.has(rule.conditionStepAlias)) {\r\n      throw createAIError(\r\n        `Logic rule references non-existent step alias: ${rule.conditionStepAlias}`,\r\n        'VALIDATION_ERROR',\r\n      );\r\n    }\r\n  }\r\n\r\n  // Validate transform blocks reference existing steps\r\n  for (const block of workflow.transformBlocks) {\r\n    for (const inputKey of block.inputKeys) {\r\n      if (!stepAliases.has(inputKey)) {\r\n        throw createAIError(\r\n          `Transform block references non-existent step alias: ${inputKey}`,\r\n          'VALIDATION_ERROR',\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Valid step types from database schema (shared/schema.ts stepTypeEnum)\r\n * This is the source of truth - must match the actual DB enum\r\n */\r\nexport const VALID_STEP_TYPES = [\r\n  // Legacy types\r\n  'short_text', 'long_text', 'multiple_choice', 'radio', 'yes_no',\r\n  'date_time', 'file_upload', 'loop_group', 'computed', 'js_question',\r\n  'repeater', 'final_documents', 'signature_block',\r\n  // Easy mode types\r\n  'true_false', 'phone', 'date', 'time', 'datetime', 'email',\r\n  'number', 'currency', 'scale', 'website', 'display', 'address', 'final',\r\n  // Advanced mode types\r\n  'text', 'boolean', 'phone_advanced', 'datetime_unified', 'choice',\r\n  'email_advanced', 'number_advanced', 'scale_advanced', 'website_advanced',\r\n  'address_advanced', 'multi_field', 'display_advanced',\r\n] as const;\r\n\r\n/**\r\n * Type mapping for AI-friendly names to DB types\r\n */\r\nexport const TYPE_ALIASES: Record<string, string> = {\r\n  'checkbox': 'multiple_choice', // Common AI mistake\r\n  'select': 'choice',\r\n  'dropdown': 'choice',\r\n  'textarea': 'long_text',\r\n  'input': 'short_text',\r\n};\r\n\r\n/**\r\n * Normalize workflow types (e.g. map AI-friendly types to DB types)\r\n */\r\nexport function normalizeWorkflowTypes(workflow: AIGeneratedWorkflow): void {\r\n  for (const section of workflow.sections) {\r\n    for (const step of section.steps) {\r\n      // Apply type alias mapping\r\n      if (TYPE_ALIASES[step.type]) {\r\n        const originalType = step.type;\r\n        step.type = TYPE_ALIASES[step.type] as any;\r\n        logger.debug({ originalType, normalizedType: step.type, stepId: step.id }, 'Normalized step type');\r\n      }\r\n\r\n      // Validate against DB schema\r\n      if (!VALID_STEP_TYPES.includes(step.type as any)) {\r\n        logger.error({\r\n          invalidType: step.type,\r\n          stepId: step.id,\r\n          stepTitle: step.title,\r\n          validTypes: VALID_STEP_TYPES\r\n        }, 'AI generated invalid step type');\r\n\r\n        throw createAIError(\r\n          `AI generated invalid step type: \"${step.type}\" for step \"${step.title}\"`,\r\n          'VALIDATION_ERROR',\r\n          {\r\n            invalidType: step.type,\r\n            stepId: step.id,\r\n            stepTitle: step.title,\r\n            validTypes: VALID_STEP_TYPES,\r\n            suggestion: 'The AI model generated a step type that is not supported by the database. This is a bug in the AI prompt or model behavior.',\r\n          }\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\IterativeQualityImprover.ts","messages":[{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 16 to the 15 allowed.","line":95,"column":9,"nodeType":null,"messageId":"refactorFunction","endLine":95,"endColumn":32},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":104,"column":44,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":104,"endColumn":46,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[3691,3693],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":207,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7727,7730],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7727,7730],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":208,"column":24,"nodeType":"Property","messageId":"anyAssignment","endLine":208,"endColumn":29},{"ruleId":"complexity","severity":2,"message":"Method 'buildImprovementPrompt' has a complexity of 17. Maximum allowed is 15.","line":220,"column":33,"nodeType":"FunctionExpression","messageId":"complex","endLine":326,"endColumn":4},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":233,"column":57,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":233,"endColumn":59,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[8727,8729],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"sonarjs/no-nested-template-literals","severity":2,"message":"Refactor this code to not use nested template literals.","line":244,"column":78,"nodeType":"TemplateLiteral","messageId":"nestedTemplateLiterals","endLine":244,"endColumn":137},{"ruleId":"sonarjs/no-nested-template-literals","severity":2,"message":"Refactor this code to not use nested template literals.","line":244,"column":110,"nodeType":"TemplateLiteral","messageId":"nestedTemplateLiterals","endLine":244,"endColumn":130},{"ruleId":"sonarjs/no-nested-template-literals","severity":2,"message":"Refactor this code to not use nested template literals.","line":250,"column":75,"nodeType":"TemplateLiteral","messageId":"nestedTemplateLiterals","endLine":250,"endColumn":134},{"ruleId":"sonarjs/no-nested-template-literals","severity":2,"message":"Refactor this code to not use nested template literals.","line":250,"column":107,"nodeType":"TemplateLiteral","messageId":"nestedTemplateLiterals","endLine":250,"endColumn":127},{"ruleId":"sonarjs/no-nested-template-literals","severity":2,"message":"Refactor this code to not use nested template literals.","line":256,"column":95,"nodeType":"TemplateLiteral","messageId":"nestedTemplateLiterals","endLine":256,"endColumn":111},{"ruleId":"sonarjs/no-nested-template-literals","severity":2,"message":"Refactor this code to not use nested template literals.","line":288,"column":104,"nodeType":"TemplateLiteral","messageId":"nestedTemplateLiterals","endLine":288,"endColumn":125},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":344,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":344,"endColumn":41},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":347,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":347,"endColumn":27,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[13246,13261],"text":"(Boolean(parsed.sections))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sections on an `any` value.","line":347,"column":19,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":347,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sections on an `any` value.","line":347,"column":53,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":347,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":354,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":354,"endColumn":46},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":354,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":354,"endColumn":28,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[13490,13502],"text":"(Boolean(parsed.title))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .title on an `any` value.","line":354,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":354,"endColumn":28},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":355,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":355,"endColumn":64},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":355,"column":22,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":355,"endColumn":40,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[13544,13562],"text":"(Boolean(parsed.description))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .description on an `any` value.","line":355,"column":29,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":355,"endColumn":40},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":356,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":356,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sections on an `any` value.","line":356,"column":26,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":356,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":357,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":357,"endColumn":67},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":357,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":357,"endColumn":38,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[13645,13662],"text":"(Boolean(parsed.logicRules))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .logicRules on an `any` value.","line":357,"column":28,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":357,"endColumn":38},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":357,"column":42,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":357,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":358,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":358,"endColumn":82},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":358,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":358,"endColumn":48,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[13719,13741],"text":"(Boolean(parsed.transformBlocks))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .transformBlocks on an `any` value.","line":358,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":358,"endColumn":48},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":358,"column":52,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":358,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":359,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":359,"endColumn":46},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":359,"column":16,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":359,"endColumn":28,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[13793,13805],"text":"(Boolean(parsed.notes))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .notes on an `any` value.","line":359,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":359,"endColumn":28}],"suppressedMessages":[],"errorCount":35,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Iterative Quality Improver\r\n *\r\n * Automatically refines AI-generated workflows by iteratively sending them back\r\n * to the AI for improvement until quality is acceptable or further refinement\r\n * isn't cost-effective.\r\n *\r\n * Cost vs Quality Balancing:\r\n * - Each iteration has a cost (API calls, tokens, time)\r\n * - Improvement follows diminishing returns curve\r\n * - Stop when: quality is good enough OR marginal improvement < threshold\r\n */\r\n\r\nimport { AIGeneratedWorkflow, AIWorkflowGenerationRequest } from '../../../shared/types/ai';\r\nimport { createLogger } from '../../logger';\r\nimport { QualityScore, WorkflowQualityValidator, workflowQualityValidator } from '../WorkflowQualityValidator';\r\n\r\nimport { AIPromptBuilder } from './AIPromptBuilder';\r\nimport { AIProviderClient } from './AIProviderClient';\r\n\r\nconst logger = createLogger({ module: 'iterative-quality-improver' });\r\n\r\nexport interface QualityImprovementConfig {\r\n  /** Minimum acceptable quality score (0-100). Default: 80 */\r\n  targetQualityScore: number;\r\n\r\n  /** Maximum iterations to attempt. Default: 3 */\r\n  maxIterations: number;\r\n\r\n  /** Minimum improvement per iteration to continue (0-100). Default: 5 */\r\n  minImprovementThreshold: number;\r\n\r\n  /** Stop if we reach this score even if max iterations not reached. Default: 95 */\r\n  excellentQualityThreshold: number;\r\n\r\n  /** Estimated cost per iteration in cents. Used for logging/metrics. Default: 5 */\r\n  estimatedCostPerIterationCents: number;\r\n\r\n  /** Maximum total cost in cents before stopping. Default: 25 (5 iterations worth) */\r\n  maxTotalCostCents: number;\r\n\r\n  /** Categories to prioritize for improvement */\r\n  priorityCategories?: Array<'aliases' | 'types' | 'structure' | 'ux' | 'completeness' | 'validation'>;\r\n}\r\n\r\nexport interface ImprovementIteration {\r\n  iteration: number;\r\n  qualityScore: QualityScore;\r\n  workflow: AIGeneratedWorkflow;\r\n  durationMs: number;\r\n  improvementFromPrevious: number;\r\n  estimatedCostCents: number;\r\n}\r\n\r\nexport interface ImprovementResult {\r\n  finalWorkflow: AIGeneratedWorkflow;\r\n  finalQualityScore: QualityScore;\r\n  iterations: ImprovementIteration[];\r\n  totalIterations: number;\r\n  totalDurationMs: number;\r\n  totalEstimatedCostCents: number;\r\n  stoppedReason: 'target_reached' | 'excellent_quality' | 'max_iterations' | 'diminishing_returns' | 'max_cost' | 'no_improvement';\r\n  qualityImprovement: number; // Total improvement from first to last\r\n}\r\n\r\nconst DEFAULT_CONFIG: QualityImprovementConfig = {\r\n  targetQualityScore: 80,\r\n  maxIterations: 3,\r\n  minImprovementThreshold: 5,\r\n  excellentQualityThreshold: 95,\r\n  estimatedCostPerIterationCents: 5,\r\n  maxTotalCostCents: 25,\r\n};\r\n\r\nexport class IterativeQualityImprover {\r\n  private client: AIProviderClient;\r\n  private promptBuilder: AIPromptBuilder;\r\n  private validator: WorkflowQualityValidator;\r\n  private config: QualityImprovementConfig;\r\n\r\n  constructor(\r\n    client: AIProviderClient,\r\n    promptBuilder: AIPromptBuilder,\r\n    config: Partial<QualityImprovementConfig> = {}\r\n  ) {\r\n    this.client = client;\r\n    this.promptBuilder = promptBuilder;\r\n    this.validator = workflowQualityValidator;\r\n    this.config = { ...DEFAULT_CONFIG, ...config };\r\n  }\r\n\r\n  /**\r\n   * Generate a workflow and iteratively improve it until quality target is met\r\n   */\r\n  async generateWithQualityLoop(\r\n    initialWorkflow: AIGeneratedWorkflow,\r\n    originalRequest: AIWorkflowGenerationRequest,\r\n    initialQualityScore?: QualityScore\r\n  ): Promise<ImprovementResult> {\r\n    const startTime = Date.now();\r\n    const iterations: ImprovementIteration[] = [];\r\n\r\n    let currentWorkflow = initialWorkflow;\r\n    let currentScore = initialQualityScore || this.validator.validate(currentWorkflow);\r\n    let totalCost = 0;\r\n\r\n    // Record initial state as iteration 0\r\n    iterations.push({\r\n      iteration: 0,\r\n      qualityScore: currentScore,\r\n      workflow: currentWorkflow,\r\n      durationMs: 0,\r\n      improvementFromPrevious: 0,\r\n      estimatedCostCents: 0,\r\n    });\r\n\r\n    logger.info({\r\n      initialScore: currentScore.overall,\r\n      targetScore: this.config.targetQualityScore,\r\n      maxIterations: this.config.maxIterations,\r\n      issues: currentScore.issues.length,\r\n    }, 'Starting iterative quality improvement');\r\n\r\n    // Check if already at target\r\n    if (currentScore.overall >= this.config.targetQualityScore) {\r\n      return this.buildResult(iterations, 'target_reached', startTime, totalCost);\r\n    }\r\n\r\n    if (currentScore.overall >= this.config.excellentQualityThreshold) {\r\n      return this.buildResult(iterations, 'excellent_quality', startTime, totalCost);\r\n    }\r\n\r\n    // Iterative improvement loop\r\n    for (let i = 1; i <= this.config.maxIterations; i++) {\r\n      const iterationStart = Date.now();\r\n\r\n      // Check cost budget\r\n      if (totalCost + this.config.estimatedCostPerIterationCents > this.config.maxTotalCostCents) {\r\n        logger.info({ totalCost, maxCost: this.config.maxTotalCostCents }, 'Stopping: max cost reached');\r\n        return this.buildResult(iterations, 'max_cost', startTime, totalCost);\r\n      }\r\n\r\n      try {\r\n        // Generate improvement prompt based on current issues\r\n        const improvementPrompt = this.buildImprovementPrompt(currentWorkflow, currentScore, originalRequest);\r\n\r\n        // Call AI for improvement\r\n        const response = await this.client.callLLM(improvementPrompt, 'workflow_revision');\r\n        const improvedWorkflow = this.parseImprovedWorkflow(response, currentWorkflow);\r\n\r\n        // Validate improved workflow\r\n        const newScore = this.validator.validate(improvedWorkflow);\r\n        const improvement = newScore.overall - currentScore.overall;\r\n\r\n        totalCost += this.config.estimatedCostPerIterationCents;\r\n\r\n        iterations.push({\r\n          iteration: i,\r\n          qualityScore: newScore,\r\n          workflow: improvedWorkflow,\r\n          durationMs: Date.now() - iterationStart,\r\n          improvementFromPrevious: improvement,\r\n          estimatedCostCents: this.config.estimatedCostPerIterationCents,\r\n        });\r\n\r\n        logger.info({\r\n          iteration: i,\r\n          previousScore: currentScore.overall,\r\n          newScore: newScore.overall,\r\n          improvement,\r\n          issues: newScore.issues.length,\r\n          duration: Date.now() - iterationStart,\r\n        }, 'Quality improvement iteration completed');\r\n\r\n        // Check stopping conditions\r\n        if (newScore.overall >= this.config.excellentQualityThreshold) {\r\n          currentWorkflow = improvedWorkflow;\r\n          currentScore = newScore;\r\n          return this.buildResult(iterations, 'excellent_quality', startTime, totalCost);\r\n        }\r\n\r\n        if (newScore.overall >= this.config.targetQualityScore) {\r\n          currentWorkflow = improvedWorkflow;\r\n          currentScore = newScore;\r\n          return this.buildResult(iterations, 'target_reached', startTime, totalCost);\r\n        }\r\n\r\n        if (improvement <= 0) {\r\n          logger.info({ improvement }, 'Stopping: no improvement in this iteration');\r\n          return this.buildResult(iterations, 'no_improvement', startTime, totalCost);\r\n        }\r\n\r\n        if (improvement < this.config.minImprovementThreshold) {\r\n          logger.info({\r\n            improvement,\r\n            threshold: this.config.minImprovementThreshold,\r\n          }, 'Stopping: diminishing returns');\r\n          currentWorkflow = improvedWorkflow;\r\n          currentScore = newScore;\r\n          return this.buildResult(iterations, 'diminishing_returns', startTime, totalCost);\r\n        }\r\n\r\n        // Continue with improved workflow\r\n        currentWorkflow = improvedWorkflow;\r\n        currentScore = newScore;\r\n\r\n      } catch (error: any) {\r\n        logger.error({ error, iteration: i }, 'Error during quality improvement iteration');\r\n        // On error, return best result so far\r\n        break;\r\n      }\r\n    }\r\n\r\n    return this.buildResult(iterations, 'max_iterations', startTime, totalCost);\r\n  }\r\n\r\n  /**\r\n   * Build a prompt that focuses on fixing specific quality issues\r\n   */\r\n  private buildImprovementPrompt(\r\n    workflow: AIGeneratedWorkflow,\r\n    score: QualityScore,\r\n    originalRequest: AIWorkflowGenerationRequest\r\n  ): string {\r\n    // Get category-specific context from the original request\r\n    const category = originalRequest.category || 'general';\r\n    const domainGuidance = this.promptBuilder.getCategoryGuidance(category);\r\n    const domainExamples = this.promptBuilder.getCategoryExamples(category);\r\n\r\n    // Group issues by category\r\n    const issuesByCategory = new Map<string, typeof score.issues>();\r\n    for (const issue of score.issues) {\r\n      const list = issuesByCategory.get(issue.category) || [];\r\n      list.push(issue);\r\n      issuesByCategory.set(issue.category, list);\r\n    }\r\n\r\n    // Prioritize categories with most severe issues\r\n    const prioritizedIssues: string[] = [];\r\n\r\n    // Errors first\r\n    const errors = score.issues.filter(i => i.type === 'error');\r\n    if (errors.length > 0) {\r\n      prioritizedIssues.push(`CRITICAL ERRORS (must fix):\\n${errors.map(e => `- ${e.message}${e.suggestion ? ` (${e.suggestion})` : ''}`).join('\\n')}`);\r\n    }\r\n\r\n    // Warnings second\r\n    const warnings = score.issues.filter(i => i.type === 'warning');\r\n    if (warnings.length > 0) {\r\n      prioritizedIssues.push(`WARNINGS (should fix):\\n${warnings.map(w => `- ${w.message}${w.suggestion ? ` (${w.suggestion})` : ''}`).join('\\n')}`);\r\n    }\r\n\r\n    // Suggestions last\r\n    const suggestions = score.issues.filter(i => i.type === 'suggestion');\r\n    if (suggestions.length > 0 && prioritizedIssues.length < 10) {\r\n      prioritizedIssues.push(`SUGGESTIONS (nice to have):\\n${suggestions.slice(0, 5).map(s => `- ${s.message}`).join('\\n')}`);\r\n    }\r\n\r\n    // Build category-specific guidance\r\n    const categoryGuidance: string[] = [];\r\n\r\n    if (score.breakdown.aliases < 80) {\r\n      categoryGuidance.push(`ALIASES (score: ${score.breakdown.aliases}/100): Use descriptive camelCase aliases like \"firstName\", \"emailAddress\", \"phoneNumber\". Avoid generic names like \"field1\", \"q1\", \"input\".`);\r\n    }\r\n\r\n    if (score.breakdown.types < 80) {\r\n      categoryGuidance.push(`TYPES (score: ${score.breakdown.types}/100): Use appropriate field types - \"email\" for email fields, \"phone\" for phone numbers, \"currency\" for money, \"date\" for dates, \"scale\" for ratings.`);\r\n    }\r\n\r\n    if (score.breakdown.structure < 80) {\r\n      categoryGuidance.push(`STRUCTURE (score: ${score.breakdown.structure}/100): Organize into logical sections. Avoid empty sections or sections with too many steps (max 15). Group related questions together.`);\r\n    }\r\n\r\n    if (score.breakdown.ux < 80) {\r\n      categoryGuidance.push(`UX (score: ${score.breakdown.ux}/100): Make question titles clear and descriptive. Add question marks to questions. Use helpful descriptions where needed.`);\r\n    }\r\n\r\n    if (score.breakdown.completeness < 80) {\r\n      categoryGuidance.push(`COMPLETENESS (score: ${score.breakdown.completeness}/100): Ensure workflow has a title. Include all necessary input fields.`);\r\n    }\r\n\r\n    if (score.breakdown.validation < 80) {\r\n      categoryGuidance.push(`VALIDATION (score: ${score.breakdown.validation}/100): Mark important fields as required. Ensure choice fields have at least 2 options.`);\r\n    }\r\n\r\n    // Build domain context section if we have a specific category\r\n    const domainContext = category !== 'general'\r\n      ? `\\nDOMAIN CONTEXT (${category.toUpperCase()} workflow):\\n${domainGuidance}\\n${domainExamples ? `\\n${domainExamples}` : ''}`\r\n      : '';\r\n\r\n    return `You are a Workflow Quality Improvement Engine.\r\n\r\nCURRENT WORKFLOW (Quality Score: ${score.overall}/100):\r\n${JSON.stringify(workflow, null, 2)}\r\n\r\nORIGINAL USER REQUEST:\r\n\"${originalRequest.description}\"\r\n${domainContext}\r\n\r\nQUALITY ISSUES TO FIX:\r\n${prioritizedIssues.join('\\n\\n')}\r\n\r\nIMPROVEMENT GUIDANCE:\r\n${categoryGuidance.join('\\n')}\r\n\r\nYOUR TASK:\r\nImprove the workflow to fix the quality issues above. Focus on:\r\n1. Fix ALL critical errors first\r\n2. Address warnings where possible\r\n3. Maintain the original workflow intent and structure\r\n4. Keep all existing steps that are working well\r\n5. Only modify what needs to be fixed\r\n${category !== 'general' ? `6. Ensure the workflow follows ${category} workflow best practices` : ''}\r\n\r\nOUTPUT FORMAT:\r\nReturn ONLY a valid JSON object with the improved workflow structure:\r\n{\r\n  \"title\": \"...\",\r\n  \"description\": \"...\",\r\n  \"sections\": [...],\r\n  \"logicRules\": [...],\r\n  \"transformBlocks\": [...]\r\n}\r\n\r\nDo NOT include any explanation or markdown - just the JSON object.`;\r\n  }\r\n\r\n  /**\r\n   * Parse the AI response into an improved workflow\r\n   */\r\n  private parseImprovedWorkflow(response: string, fallback: AIGeneratedWorkflow): AIGeneratedWorkflow {\r\n    try {\r\n      // Try to extract JSON from response\r\n      let jsonStr = response.trim();\r\n\r\n      // Handle markdown code blocks\r\n      if (jsonStr.startsWith('```')) {\r\n        const match = jsonStr.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\r\n        if (match) {\r\n          jsonStr = match[1].trim();\r\n        }\r\n      }\r\n\r\n      const parsed = JSON.parse(jsonStr);\r\n\r\n      // Validate basic structure\r\n      if (!parsed.sections || !Array.isArray(parsed.sections)) {\r\n        logger.warn('Improved workflow missing sections array, using fallback');\r\n        return fallback;\r\n      }\r\n\r\n      // Ensure required fields exist\r\n      return {\r\n        title: parsed.title || fallback.title,\r\n        description: parsed.description || fallback.description,\r\n        sections: parsed.sections,\r\n        logicRules: parsed.logicRules || fallback.logicRules || [],\r\n        transformBlocks: parsed.transformBlocks || fallback.transformBlocks || [],\r\n        notes: parsed.notes || fallback.notes,\r\n      };\r\n    } catch (error: unknown) {\r\n      const errorMessage = error instanceof Error ? error.message : String(error);\r\n      logger.error({ error: errorMessage }, 'Failed to parse improved workflow, using fallback');\r\n      return fallback;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build the final result object\r\n   */\r\n  private buildResult(\r\n    iterations: ImprovementIteration[],\r\n    stoppedReason: ImprovementResult['stoppedReason'],\r\n    startTime: number,\r\n    totalCost: number\r\n  ): ImprovementResult {\r\n    const lastIteration = iterations[iterations.length - 1];\r\n    const firstIteration = iterations[0];\r\n\r\n    const result: ImprovementResult = {\r\n      finalWorkflow: lastIteration.workflow,\r\n      finalQualityScore: lastIteration.qualityScore,\r\n      iterations,\r\n      totalIterations: iterations.length - 1, // Exclude initial iteration 0\r\n      totalDurationMs: Date.now() - startTime,\r\n      totalEstimatedCostCents: totalCost,\r\n      stoppedReason,\r\n      qualityImprovement: lastIteration.qualityScore.overall - firstIteration.qualityScore.overall,\r\n    };\r\n\r\n    logger.info({\r\n      finalScore: result.finalQualityScore.overall,\r\n      totalIterations: result.totalIterations,\r\n      totalDuration: result.totalDurationMs,\r\n      totalCost: result.totalEstimatedCostCents,\r\n      stoppedReason,\r\n      qualityImprovement: result.qualityImprovement,\r\n    }, 'Iterative quality improvement completed');\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Quick check if a workflow needs improvement\r\n   */\r\n  needsImprovement(qualityScore: QualityScore): boolean {\r\n    return qualityScore.overall < this.config.targetQualityScore;\r\n  }\r\n\r\n  /**\r\n   * Estimate if improvement is worth the cost\r\n   */\r\n  estimateImprovementValue(currentScore: number): { worthIt: boolean; reason: string } {\r\n    const potentialImprovement = this.config.targetQualityScore - currentScore;\r\n\r\n    if (currentScore >= this.config.targetQualityScore) {\r\n      return { worthIt: false, reason: 'Already at target quality' };\r\n    }\r\n\r\n    if (currentScore >= this.config.excellentQualityThreshold) {\r\n      return { worthIt: false, reason: 'Already excellent quality' };\r\n    }\r\n\r\n    // Estimate iterations needed (rough heuristic)\r\n    const estimatedIterations = Math.ceil(potentialImprovement / 10);\r\n    const estimatedCost = estimatedIterations * this.config.estimatedCostPerIterationCents;\r\n\r\n    if (estimatedCost > this.config.maxTotalCostCents) {\r\n      return {\r\n        worthIt: true,\r\n        reason: `May need ${estimatedIterations} iterations (~${estimatedCost}), will cap at ${this.config.maxTotalCostCents}`,\r\n      };\r\n    }\r\n\r\n    return {\r\n      worthIt: true,\r\n      reason: `Estimated ${estimatedIterations} iterations (~${estimatedCost}) to reach target`,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Create an IterativeQualityImprover with default configuration\r\n */\r\nexport function createQualityImprover(\r\n  client: AIProviderClient,\r\n  promptBuilder: AIPromptBuilder,\r\n  config?: Partial<QualityImprovementConfig>\r\n): IterativeQualityImprover {\r\n  return new IterativeQualityImprover(client, promptBuilder, config);\r\n}\r\n\r\nexport default IterativeQualityImprover;\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\ModelRegistry.ts","messages":[{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `workflow_generation` must match one of the following formats: camelCase","line":28,"column":3,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":28,"endColumn":22},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `workflow_revision` must match one of the following formats: camelCase","line":29,"column":3,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":29,"endColumn":20},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `workflow_suggestion` must match one of the following formats: camelCase","line":30,"column":3,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":30,"endColumn":22},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `binding_suggestion` must match one of the following formats: camelCase","line":31,"column":3,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":31,"endColumn":21},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `value_suggestion` must match one of the following formats: camelCase","line":32,"column":3,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":32,"endColumn":19},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `logic_generation` must match one of the following formats: camelCase","line":33,"column":3,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":33,"endColumn":19},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `logic_debug` must match one of the following formats: camelCase","line":34,"column":3,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":34,"endColumn":14},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `logic_visualization` must match one of the following formats: camelCase","line":35,"column":3,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":35,"endColumn":22},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":107,"column":3,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":107,"endColumn":28},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"never\" of template literal expression.","line":162,"column":46,"nodeType":"Identifier","messageId":"invalidType","endLine":162,"endColumn":54}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Model Registry\r\n *\r\n * Centralized registry for all AI model configurations including:\r\n * - Context window limits\r\n * - Token pricing (per 1M tokens)\r\n * - Default max tokens for different task types\r\n */\r\n\r\nimport type { TaskType } from './types';\r\nimport type { AIProvider } from '../../../shared/types/ai';\r\n\r\nexport interface ModelConfig {\r\n  provider: AIProvider;\r\n  model: string;\r\n  maxContextTokens: number;\r\n  pricing: {\r\n    input: number;  // USD per 1M tokens\r\n    output: number; // USD per 1M tokens\r\n  };\r\n}\r\n\r\n/**\r\n * Task-specific max output tokens\r\n * These are conservative defaults to leave room for prompts\r\n */\r\nexport const TASK_MAX_TOKENS: Record<TaskType, number> = {\r\n  workflow_generation: 8000,\r\n  workflow_revision: 8192,\r\n  workflow_suggestion: 4000,\r\n  binding_suggestion: 4000,\r\n  value_suggestion: 4000,\r\n  logic_generation: 4000,\r\n  logic_debug: 4000,\r\n  logic_visualization: 4000,\r\n};\r\n\r\n/**\r\n * Comprehensive model configurations\r\n */\r\nconst MODEL_CONFIGS: ModelConfig[] = [\r\n  // OpenAI Models\r\n  {\r\n    provider: 'openai',\r\n    model: 'gpt-4-turbo-preview',\r\n    maxContextTokens: 128000,\r\n    pricing: { input: 10.00, output: 30.00 },\r\n  },\r\n  {\r\n    provider: 'openai',\r\n    model: 'gpt-4',\r\n    maxContextTokens: 8192,\r\n    pricing: { input: 30.00, output: 60.00 },\r\n  },\r\n  {\r\n    provider: 'openai',\r\n    model: 'gpt-3.5-turbo',\r\n    maxContextTokens: 16385,\r\n    pricing: { input: 0.50, output: 1.50 },\r\n  },\r\n\r\n  // Anthropic Models\r\n  {\r\n    provider: 'anthropic',\r\n    model: 'claude-3-5-sonnet-20241022',\r\n    maxContextTokens: 200000,\r\n    pricing: { input: 3.00, output: 15.00 },\r\n  },\r\n  {\r\n    provider: 'anthropic',\r\n    model: 'claude-3-opus-20240229',\r\n    maxContextTokens: 200000,\r\n    pricing: { input: 15.00, output: 75.00 },\r\n  },\r\n  {\r\n    provider: 'anthropic',\r\n    model: 'claude-3-sonnet-20240229',\r\n    maxContextTokens: 200000,\r\n    pricing: { input: 3.00, output: 15.00 },\r\n  },\r\n\r\n  // Gemini Models\r\n  {\r\n    provider: 'gemini',\r\n    model: 'gemini-2.0-flash',\r\n    maxContextTokens: 1048576, // 1M tokens\r\n    pricing: { input: 0.10, output: 0.40 },\r\n  },\r\n  {\r\n    provider: 'gemini',\r\n    model: 'gemini-1.5-pro',\r\n    maxContextTokens: 2097152, // 2M tokens\r\n    pricing: { input: 1.25, output: 5.00 },\r\n  },\r\n];\r\n\r\n/**\r\n * Model Registry - Single source of truth for model configurations\r\n */\r\nexport class ModelRegistry {\r\n  private static configMap = new Map<string, ModelConfig>();\r\n  private static initialized = false;\r\n\r\n  /**\r\n   * Initialize the registry (called once)\r\n   */\r\n  private static initialize() {\r\n    if (this.initialized) {return;}\r\n\r\n    for (const config of MODEL_CONFIGS) {\r\n      const key = `${config.provider}:${config.model}`;\r\n      this.configMap.set(key, config);\r\n    }\r\n\r\n    this.initialized = true;\r\n  }\r\n\r\n  /**\r\n   * Get model configuration\r\n   */\r\n  static getConfig(provider: AIProvider, model: string): ModelConfig {\r\n    this.initialize();\r\n\r\n    const key = `${provider}:${model}`;\r\n    const config = this.configMap.get(key);\r\n\r\n    if (!config) {\r\n      // Return reasonable defaults for unknown models\r\n      return this.getDefaultConfig(provider);\r\n    }\r\n\r\n    return config;\r\n  }\r\n\r\n  /**\r\n   * Get default configuration for a provider (fallback)\r\n   */\r\n  private static getDefaultConfig(provider: AIProvider): ModelConfig {\r\n    switch (provider) {\r\n      case 'openai':\r\n        return {\r\n          provider: 'openai',\r\n          model: 'unknown',\r\n          maxContextTokens: 8000,\r\n          pricing: { input: 10.00, output: 30.00 },\r\n        };\r\n      case 'anthropic':\r\n        return {\r\n          provider: 'anthropic',\r\n          model: 'unknown',\r\n          maxContextTokens: 100000,\r\n          pricing: { input: 3.00, output: 15.00 },\r\n        };\r\n      case 'gemini':\r\n        return {\r\n          provider: 'gemini',\r\n          model: 'unknown',\r\n          maxContextTokens: 1000000,\r\n          pricing: { input: 0.10, output: 0.40 },\r\n        };\r\n      default:\r\n        throw new Error(`Unknown provider: ${provider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get max context tokens for a model\r\n   */\r\n  static getMaxContextTokens(provider: AIProvider, model: string): number {\r\n    return this.getConfig(provider, model).maxContextTokens;\r\n  }\r\n\r\n  /**\r\n   * Get pricing for a model\r\n   */\r\n  static getPricing(provider: AIProvider, model: string): { input: number; output: number } {\r\n    return this.getConfig(provider, model).pricing;\r\n  }\r\n\r\n  /**\r\n   * Estimate cost for a request\r\n   */\r\n  static estimateCost(\r\n    provider: AIProvider,\r\n    model: string,\r\n    promptTokens: number,\r\n    responseTokens: number\r\n  ): number {\r\n    const pricing = this.getPricing(provider, model);\r\n    return (\r\n      (promptTokens / 1_000_000) * pricing.input +\r\n      (responseTokens / 1_000_000) * pricing.output\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get max output tokens for a task type\r\n   */\r\n  static getTaskMaxTokens(taskType: TaskType): number {\r\n    return TASK_MAX_TOKENS[taskType];\r\n  }\r\n\r\n  /**\r\n   * Get all supported models for a provider\r\n   */\r\n  static getModelsForProvider(provider: AIProvider): string[] {\r\n    this.initialize();\r\n\r\n    const models: string[] = [];\r\n    for (const config of this.configMap.values()) {\r\n      if (config.provider === provider) {\r\n        models.push(config.model);\r\n      }\r\n    }\r\n\r\n    return models;\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\WorkflowGenerationService.ts","messages":[{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":15,"column":5,"nodeType":"ImportSpecifier","endLine":15,"endColumn":18},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":60,"column":68,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":60,"endColumn":70,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[1925,1927],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":80,"column":19,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":80,"endColumn":48},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":122,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4613,4616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4613,4616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .__qualityScore on an `any` value.","line":122,"column":32,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":122,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":125,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4707,4710],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4707,4710],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":133,"column":28,"nodeType":"Property","messageId":"anyAssignment","endLine":133,"endColumn":33},{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":136,"column":23,"nodeType":"Identifier","endLine":136,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":143,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":143,"endColumn":27},{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":144,"column":23,"nodeType":"Identifier","endLine":144,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":147,"column":23,"nodeType":"Property","messageId":"anyAssignment","endLine":147,"endColumn":43},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":192,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7610,7613],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7610,7613],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .__qualityScore on an `any` value.","line":192,"column":62,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":192,"endColumn":76},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":195,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7724,7727],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7724,7727],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .__qualityScore on an `any` value.","line":195,"column":41,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":195,"endColumn":55}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport {\r\n    AIGeneratedWorkflowSchema,\r\n    AIWorkflowGenerationRequest,\r\n    AIGeneratedWorkflow,\r\n    DEFAULT_MIN_QUALITY_SCORE,\r\n} from '../../../shared/types/ai';\r\nimport { createLogger } from '../../logger';\r\nimport { QualityScore, workflowQualityValidator } from '../WorkflowQualityValidator';\n\r\nimport { QualityThresholdError } from './AIError';\r\nimport { AIPromptBuilder } from './AIPromptBuilder';\r\nimport { AIProviderClient } from './AIProviderClient';\r\nimport {\r\n    createAIError,\r\n    normalizeWorkflowTypes,\r\n    validateWorkflowStructure,\r\n} from './AIServiceUtils';\r\nimport {\r\n    IterativeQualityImprover,\r\n    QualityImprovementConfig,\r\n    ImprovementResult,\r\n} from './IterativeQualityImprover';\r\n\r\n/**\r\n * Get the minimum quality threshold from various sources\r\n * Priority: request param > environment variable > default (60)\r\n */\r\nfunction getMinQualityThreshold(requestMinScore?: number): number {\r\n    // 1. Request parameter takes highest priority\r\n    if (requestMinScore !== undefined && requestMinScore !== null) {\r\n        return requestMinScore;\r\n    }\r\n\r\n    // 2. Environment variable\r\n    const envThreshold = process.env.AI_MIN_QUALITY_SCORE;\r\n    if (envThreshold) {\r\n        const parsed = parseInt(envThreshold, 10);\r\n        if (!isNaN(parsed) && parsed >= 0 && parsed <= 100) {\r\n            return parsed;\r\n        }\r\n    }\r\n\r\n    // 3. Default value\r\n    return DEFAULT_MIN_QUALITY_SCORE;\r\n}\r\n\r\nconst logger = createLogger({ module: 'workflow-generation-service' });\r\n\r\nexport class WorkflowGenerationService {\r\n    constructor(\r\n        private client: AIProviderClient,\r\n        private promptBuilder: AIPromptBuilder,\r\n    ) { }\r\n\r\n    /**\r\n     * Create a service instance with proper config\r\n     */\r\n    static create(client: AIProviderClient, promptBuilder?: AIPromptBuilder): WorkflowGenerationService {\r\n        return new WorkflowGenerationService(client, promptBuilder || new AIPromptBuilder());\r\n    }\r\n\r\n    /**\r\n     * Generate a new workflow from a natural language description\r\n     *\r\n     * @param request - The generation request including optional minQualityScore\r\n     * @throws {QualityThresholdError} If generated workflow quality is below threshold\r\n     */\r\n    async generateWorkflow(\r\n        request: AIWorkflowGenerationRequest,\r\n    ): Promise<AIGeneratedWorkflow> {\r\n        const startTime = Date.now();\r\n        const minQualityThreshold = getMinQualityThreshold(request.minQualityScore);\r\n\r\n        try {\r\n            const prompt = this.promptBuilder.buildWorkflowGenerationPrompt(request);\r\n            const response = await this.client.callLLM(prompt, 'workflow_generation');\r\n\r\n            // Parse and validate the response\r\n            const parsed = JSON.parse(response);\r\n            const validated = AIGeneratedWorkflowSchema.parse(parsed);\r\n\r\n            // Validate and Normalize workflow structure\r\n            normalizeWorkflowTypes(validated);\r\n            validateWorkflowStructure(validated);\r\n\r\n            // Quality validation\r\n            const qualityScore = workflowQualityValidator.validate(validated);\r\n\r\n            const duration = Date.now() - startTime;\r\n            logger.info({\r\n                duration,\r\n                sectionsCount: validated.sections.length,\r\n                rulesCount: validated.logicRules.length,\r\n                blocksCount: validated.transformBlocks.length,\r\n                qualityScore: qualityScore.overall,\r\n                qualityBreakdown: qualityScore.breakdown,\r\n                qualityPassed: qualityScore.passed,\r\n                issuesCount: qualityScore.issues.length,\r\n                minQualityThreshold,\r\n            }, 'AI workflow generation succeeded');\r\n\r\n            // Check quality threshold - reject if below minimum\r\n            if (qualityScore.overall < minQualityThreshold) {\r\n                logger.warn({\r\n                    qualityScore: qualityScore.overall,\r\n                    threshold: minQualityThreshold,\r\n                    issues: qualityScore.issues.length,\r\n                    duration,\r\n                }, 'AI workflow rejected: quality below threshold');\r\n\r\n                throw new QualityThresholdError({\r\n                    qualityScore: qualityScore.overall,\r\n                    threshold: minQualityThreshold,\r\n                    issues: qualityScore.issues,\r\n                    suggestions: qualityScore.suggestions,\r\n                    breakdown: qualityScore.breakdown,\r\n                });\r\n            }\r\n\r\n            // Attach quality metadata to response (will be used by routes)\r\n            (validated as any).__qualityScore = qualityScore;\r\n\r\n            return validated;\r\n        } catch (error: any) {\r\n            const duration = Date.now() - startTime;\r\n\r\n            // Re-throw QualityThresholdError without additional wrapping\r\n            if (error instanceof QualityThresholdError) {\r\n                throw error;\r\n            }\r\n\r\n            logger.error({ error, duration }, 'AI workflow generation failed');\r\n\r\n            if (error instanceof SyntaxError) {\r\n                throw createAIError(\r\n                    'Failed to parse AI response as JSON',\r\n                    'INVALID_RESPONSE',\r\n                    { originalError: error.message },\r\n                );\r\n            }\r\n\r\n            if (error.name === 'ZodError') {\r\n                throw createAIError(\r\n                    'AI response does not match expected schema',\r\n                    'VALIDATION_ERROR',\r\n                    { originalError: error },\r\n                );\r\n            }\r\n\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate a workflow with automatic iterative quality improvement.\r\n     *\r\n     * This method generates an initial workflow, then iteratively refines it\r\n     * until quality targets are met or cost limits are reached.\r\n     *\r\n     * Note: Quality threshold rejection is bypassed in this method because the\r\n     * quality loop will attempt to improve the workflow. After improvement,\r\n     * if the final score is still below the minimum threshold, it will be rejected.\r\n     *\r\n     * @param request - The generation request with description and constraints\r\n     * @param qualityConfig - Optional configuration for quality improvement loop\r\n     * @returns The improved workflow with quality metrics and iteration details\r\n     * @throws {QualityThresholdError} If final workflow quality is still below threshold after improvement\r\n     */\r\n    async generateWorkflowWithQualityLoop(\r\n        request: AIWorkflowGenerationRequest,\r\n        qualityConfig?: Partial<QualityImprovementConfig>,\r\n    ): Promise<{\r\n        workflow: AIGeneratedWorkflow;\r\n        qualityScore: QualityScore;\r\n        improvement: ImprovementResult;\r\n    }> {\r\n        const startTime = Date.now();\r\n        const minQualityThreshold = getMinQualityThreshold(request.minQualityScore);\r\n\r\n        logger.info({\r\n            description: request.description?.substring(0, 100),\r\n            qualityConfig,\r\n            minQualityThreshold,\r\n        }, 'Starting workflow generation with quality loop');\r\n\r\n        // Step 1: Generate initial workflow (bypass threshold check for quality loop)\r\n        // We temporarily set minQualityScore to 0 to allow the initial generation to pass\r\n        // The quality loop will try to improve it, and we'll check threshold at the end\r\n        const initialRequest = { ...request, minQualityScore: 0 };\r\n        const initialWorkflow = await this.generateWorkflow(initialRequest);\r\n        const initialQualityScore = (initialWorkflow as any).__qualityScore as QualityScore;\r\n\r\n        // Clean up internal metadata\r\n        delete (initialWorkflow as any).__qualityScore;\r\n\r\n        logger.info({\r\n            initialScore: initialQualityScore.overall,\r\n            passed: initialQualityScore.passed,\r\n            issues: initialQualityScore.issues.length,\r\n            minQualityThreshold,\r\n        }, 'Initial workflow generated, checking if improvement needed');\r\n\r\n        // Step 2: Check if improvement is needed\r\n        const targetScore = qualityConfig?.targetQualityScore ?? 80;\r\n\r\n        if (initialQualityScore.overall >= targetScore) {\r\n            logger.info({\r\n                score: initialQualityScore.overall,\r\n                target: targetScore,\r\n            }, 'Initial workflow meets quality target, skipping improvement loop');\r\n\r\n            // Check minimum threshold before returning\r\n            if (initialQualityScore.overall < minQualityThreshold) {\r\n                logger.warn({\r\n                    qualityScore: initialQualityScore.overall,\r\n                    threshold: minQualityThreshold,\r\n                }, 'Workflow rejected: quality below minimum threshold');\r\n\r\n                throw new QualityThresholdError({\r\n                    qualityScore: initialQualityScore.overall,\r\n                    threshold: minQualityThreshold,\r\n                    issues: initialQualityScore.issues,\r\n                    suggestions: initialQualityScore.suggestions,\r\n                    breakdown: initialQualityScore.breakdown,\r\n                });\r\n            }\r\n\r\n            return {\r\n                workflow: initialWorkflow,\r\n                qualityScore: initialQualityScore,\r\n                improvement: {\r\n                    finalWorkflow: initialWorkflow,\r\n                    finalQualityScore: initialQualityScore,\r\n                    iterations: [{\r\n                        iteration: 0,\r\n                        qualityScore: initialQualityScore,\r\n                        workflow: initialWorkflow,\r\n                        durationMs: Date.now() - startTime,\r\n                        improvementFromPrevious: 0,\r\n                        estimatedCostCents: 0,\r\n                    }],\r\n                    totalIterations: 0,\r\n                    totalDurationMs: Date.now() - startTime,\r\n                    totalEstimatedCostCents: 0,\r\n                    stoppedReason: 'target_reached',\r\n                    qualityImprovement: 0,\r\n                },\r\n            };\r\n        }\r\n\r\n        // Step 3: Run iterative improvement\r\n        const improver = new IterativeQualityImprover(\r\n            this.client,\r\n            this.promptBuilder,\r\n            qualityConfig,\r\n        );\r\n\r\n        const improvementResult = await improver.generateWithQualityLoop(\r\n            initialWorkflow,\r\n            request,\r\n            initialQualityScore,\r\n        );\r\n\r\n        const totalDuration = Date.now() - startTime;\r\n\r\n        logger.info({\r\n            initialScore: initialQualityScore.overall,\r\n            finalScore: improvementResult.finalQualityScore.overall,\r\n            improvement: improvementResult.qualityImprovement,\r\n            iterations: improvementResult.totalIterations,\r\n            stoppedReason: improvementResult.stoppedReason,\r\n            totalDuration,\r\n            totalCost: improvementResult.totalEstimatedCostCents,\r\n            minQualityThreshold,\r\n        }, 'Workflow generation with quality loop completed');\r\n\r\n        // Check minimum threshold after improvement loop\r\n        if (improvementResult.finalQualityScore.overall < minQualityThreshold) {\r\n            logger.warn({\r\n                finalScore: improvementResult.finalQualityScore.overall,\r\n                threshold: minQualityThreshold,\r\n                iterations: improvementResult.totalIterations,\r\n            }, 'Workflow rejected after improvement: quality still below minimum threshold');\r\n\r\n            throw new QualityThresholdError({\r\n                qualityScore: improvementResult.finalQualityScore.overall,\r\n                threshold: minQualityThreshold,\r\n                issues: improvementResult.finalQualityScore.issues,\r\n                suggestions: improvementResult.finalQualityScore.suggestions,\r\n                breakdown: improvementResult.finalQualityScore.breakdown,\r\n            });\r\n        }\r\n\r\n        return {\r\n            workflow: improvementResult.finalWorkflow,\r\n            qualityScore: improvementResult.finalQualityScore,\r\n            improvement: improvementResult,\r\n        };\r\n    }\r\n}\r\n\r\n// Singleton export removed - services create their own instances via dependency injection\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\WorkflowLogicService.ts","messages":[{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":10,"column":10,"nodeType":"ImportSpecifier","endLine":10,"endColumn":23},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":44,"column":19,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":44,"endColumn":48},{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":57,"column":23,"nodeType":"Identifier","endLine":57,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":75,"column":19,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":75,"endColumn":48},{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":92,"column":23,"nodeType":"Identifier","endLine":92,"endColumn":36},{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":100,"column":23,"nodeType":"Identifier","endLine":100,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":123,"column":19,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":123,"endColumn":48},{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":140,"column":23,"nodeType":"Identifier","endLine":140,"endColumn":36},{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":148,"column":23,"nodeType":"Identifier","endLine":148,"endColumn":36}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n    AIConnectLogicResponseSchema,\r\n    AIDebugLogicResponseSchema,\r\n    AIVisualizeLogicResponseSchema,\r\n} from '../../../shared/types/ai';\r\nimport { createLogger } from '../../logger';\n\r\nimport { AIPromptBuilder } from './AIPromptBuilder';\r\nimport { AIProviderClient } from './AIProviderClient';\r\nimport { createAIError } from './AIServiceUtils';\r\n\r\nimport type {\r\n    AIConnectLogicRequest,\r\n    AIConnectLogicResponse,\r\n    AIDebugLogicRequest,\r\n    AIDebugLogicResponse,\r\n    AIVisualizeLogicRequest,\r\n    AIVisualizeLogicResponse,\r\n} from '../../../shared/types/ai';\r\n\r\nconst logger = createLogger({ module: 'workflow-logic-service' });\r\n\r\nexport class WorkflowLogicService {\r\n    private client: AIProviderClient;\r\n    private promptBuilder: AIPromptBuilder;\r\n\r\n    constructor(client: AIProviderClient, promptBuilder: AIPromptBuilder) {\r\n        this.client = client;\r\n        this.promptBuilder = promptBuilder;\r\n    }\r\n\r\n    /**\r\n     * Generate logic connections based on natural language description\r\n     */\r\n    async generateLogic(\r\n        request: AIConnectLogicRequest,\r\n    ): Promise<AIConnectLogicResponse> {\r\n        const startTime = Date.now();\r\n\r\n        try {\r\n            const prompt = this.promptBuilder.buildLogicGenerationPrompt(request);\r\n            const response = await this.client.callLLM(prompt, 'logic_generation');\r\n\r\n            const parsed = JSON.parse(response);\r\n            const validated = AIConnectLogicResponseSchema.parse(parsed);\r\n\r\n            const duration = Date.now() - startTime;\r\n            logger.info({\r\n                duration,\r\n                workflowId: request.workflowId,\r\n                changeCount: validated.diff.changes.length,\r\n            }, 'AI logic generation succeeded');\r\n\r\n            return validated;\r\n        } catch (error) {\r\n            if (error instanceof SyntaxError || (error instanceof Error && error.name === 'ZodError')) {\r\n                throw createAIError('Invalid AI Response', 'VALIDATION_ERROR', { originalError: error });\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Debug logic for contradictions and issues\r\n     */\r\n    async debugLogic(\r\n        request: AIDebugLogicRequest,\r\n    ): Promise<AIDebugLogicResponse> {\r\n        const startTime = Date.now();\r\n\r\n        try {\r\n            const prompt = this.promptBuilder.buildLogicDebugPrompt(request);\r\n            const response = await this.client.callLLM(prompt, 'logic_debug');\r\n\r\n            const parsed = JSON.parse(response);\r\n            const validated = AIDebugLogicResponseSchema.parse(parsed);\r\n\r\n            const duration = Date.now() - startTime;\r\n            logger.info({\r\n                duration,\r\n                workflowId: request.workflowId,\r\n                issuesCount: validated.issues.length,\r\n                fixesCount: validated.recommendedFixes.length,\r\n            }, 'AI logic debug succeeded');\r\n\r\n            return validated;\r\n        } catch (error) {\r\n            const duration = Date.now() - startTime;\r\n            logger.error({ error, duration }, 'AI logic debug failed');\r\n\r\n            if (error instanceof SyntaxError) {\r\n                throw createAIError(\r\n                    'Failed to parse AI response as JSON',\r\n                    'INVALID_RESPONSE',\r\n                    { originalError: error.message },\r\n                );\r\n            }\r\n\r\n            if (error instanceof Error && error.name === 'ZodError') {\r\n                throw createAIError(\r\n                    'AI response does not match expected schema',\r\n                    'VALIDATION_ERROR',\r\n                    { originalError: error },\r\n                );\r\n            }\r\n\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Visualize logic as a graph\r\n     */\r\n    async visualizeLogic(\r\n        request: AIVisualizeLogicRequest,\r\n    ): Promise<AIVisualizeLogicResponse> {\r\n        const startTime = Date.now();\r\n\r\n        try {\r\n            const prompt = this.promptBuilder.buildLogicVisualizationPrompt(request);\r\n            const response = await this.client.callLLM(prompt, 'logic_visualization');\r\n\r\n            const parsed = JSON.parse(response);\r\n            const validated = AIVisualizeLogicResponseSchema.parse(parsed);\r\n\r\n            const duration = Date.now() - startTime;\r\n            logger.info({\r\n                duration,\r\n                workflowId: request.workflowId,\r\n                nodesCount: validated.graph.nodes.length,\r\n                edgesCount: validated.graph.edges.length,\r\n            }, 'AI logic visualization succeeded');\r\n\r\n            return validated;\r\n        } catch (error) {\r\n            const duration = Date.now() - startTime;\r\n            logger.error({ error, duration }, 'AI logic visualization failed');\r\n\r\n            if (error instanceof SyntaxError) {\r\n                throw createAIError(\r\n                    'Failed to parse AI response as JSON',\r\n                    'INVALID_RESPONSE',\r\n                    { originalError: error.message },\r\n                );\r\n            }\r\n\r\n            if (error instanceof Error && error.name === 'ZodError') {\r\n                throw createAIError(\r\n                    'AI response does not match expected schema',\r\n                    'VALIDATION_ERROR',\r\n                    { originalError: error },\r\n                );\r\n            }\r\n\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\WorkflowOptimizationService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'OptimizationCategory' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":25},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'analyze' has no 'await' expression.","line":18,"column":5,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":18,"endColumn":18},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'applyFixes' has no 'await' expression.","line":54,"column":5,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":54,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `{ pageId: string; splitAtIndex: number; }`.","line":63,"column":62,"nodeType":"TSAsExpression","messageId":"unsafeArgument","endLine":63,"endColumn":80},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":63,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2316,2319],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2316,2319],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `{ sourcePageId: string; targetPageId: string; }`.","line":67,"column":63,"nodeType":"TSAsExpression","messageId":"unsafeArgument","endLine":67,"endColumn":81},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2514,2517],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2514,2517],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `{ blockId: string; }`.","line":71,"column":64,"nodeType":"TSAsExpression","messageId":"unsafeArgument","endLine":71,"endColumn":82},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2714,2717],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2714,2717],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `{ blockId: string; targetPageId: string; index: number; }`.","line":75,"column":62,"nodeType":"TSAsExpression","messageId":"unsafeArgument","endLine":75,"endColumn":80},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":75,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2910,2913],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2910,2913],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":94,"column":23,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":94,"endColumn":37},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":97,"column":28,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":97,"endColumn":39},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":182,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":182,"endColumn":32,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[7231,7246],"text":"Boolean(block.visibleIf)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":240,"column":5,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":240,"endColumn":27},{"ruleId":"no-param-reassign","severity":2,"message":"Assignment to property of function parameter 'p'.","line":260,"column":46,"nodeType":"Identifier","messageId":"assignmentToFunctionParamProp","endLine":260,"endColumn":47},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":263,"column":5,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":263,"endColumn":28},{"ruleId":"no-param-reassign","severity":2,"message":"Assignment to property of function parameter 'p'.","line":279,"column":46,"nodeType":"Identifier","messageId":"assignmentToFunctionParamProp","endLine":279,"endColumn":47},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":282,"column":5,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":282,"endColumn":29},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":292,"column":5,"nodeType":"FunctionExpression","messageId":"missingReturnType","endLine":292,"endColumn":27},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":323,"column":23,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":323,"endColumn":37},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":329,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":329,"endColumn":28,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[12985,12996],"text":"Boolean(b.visibleIf)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":331,"column":23,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":331,"endColumn":58},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":331,"column":34,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":331,"endColumn":52,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[13090,13108],"text":"(Boolean((b.config?.branches)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":332,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":332,"endColumn":46},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":367,"column":23,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":367,"endColumn":37},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":369,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":369,"endColumn":25}],"suppressedMessages":[],"errorCount":27,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport { v4 as uuidv4 } from \"uuid\";\r\n\r\nimport {\r\n    OptimizationIssue,\r\n    OptimizationResult,\r\n    OptimizationSuggestion,\r\n    WorkflowMetrics,\r\n    OptimizationFix,\r\n    OptimizationCategory,\r\n} from \"@shared/types/optimization\";\r\nimport { WorkflowJSON, WorkflowPage, WorkflowBlock } from \"@shared/types/workflow\";\r\n\r\nexport class WorkflowOptimizationService {\r\n    /**\r\n     * Main entry point to analyze a workflow\r\n     */\r\n    async analyze(workflow: WorkflowJSON, options: { includePageStructure?: boolean; includeBlockStructure?: boolean; includeLogicAnalysis?: boolean } = {}): Promise<OptimizationResult> {\r\n        const issues: OptimizationIssue[] = [];\r\n        const suggestions: OptimizationSuggestion[] = [];\r\n\r\n        // 1. Calculate basic metrics\r\n        const metrics = this.calculateMetrics(workflow);\r\n\r\n        // 2. Run Analyzers based on options or default to all\r\n        if (options.includePageStructure !== false) {\r\n            issues.push(...this.analyzePageStructure(workflow));\r\n        }\r\n        if (options.includeBlockStructure !== false) {\r\n            issues.push(...this.analyzeBlockStructure(workflow));\r\n        }\r\n        if (options.includeLogicAnalysis !== false) {\r\n            issues.push(...this.analyzeLogic(workflow));\r\n        }\r\n\r\n        // 3. Generate Suggestions from Issues\r\n        suggestions.push(...this.generateSuggestions(issues, workflow));\r\n\r\n        // 4. Calculate Score\r\n        const optimizationScore = this.calculateScore(issues, metrics);\r\n\r\n        return {\r\n            issues,\r\n            suggestions,\r\n            optimizationScore,\r\n            metrics,\r\n            timestamp: new Date().toISOString(),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Applies a list of fixes to the workflow and returns the result\r\n     */\r\n    async applyFixes(workflow: WorkflowJSON, fixes: OptimizationFix[]): Promise<{ updatedWorkflow: WorkflowJSON, appliedCount: number }> {\r\n        // Deep clone to avoid mutating original\r\n        const updatedWorkflow = JSON.parse(JSON.stringify(workflow)) as WorkflowJSON;\r\n        let appliedCount = 0;\r\n\r\n        for (const fix of fixes) {\r\n            try {\r\n                switch (fix.type) {\r\n                    case \"split_page\":\r\n                        this.applySplitPage(updatedWorkflow, fix.payload as any);\r\n                        appliedCount++;\r\n                        break;\r\n                    case \"merge_pages\":\r\n                        this.applyMergePages(updatedWorkflow, fix.payload as any);\r\n                        appliedCount++;\r\n                        break;\r\n                    case \"delete_block\":\r\n                        this.applyDeleteBlock(updatedWorkflow, fix.payload as any);\r\n                        appliedCount++;\r\n                        break;\r\n                    case \"move_block\":\r\n                        this.applyMoveBlock(updatedWorkflow, fix.payload as any);\r\n                        appliedCount++;\r\n                        break;\r\n                    // Add other fix types here\r\n                }\r\n            } catch (err) {\r\n                console.error(`Failed to apply fix ${fix.type}:`, err);\r\n            }\r\n        }\r\n\r\n        return { updatedWorkflow, appliedCount };\r\n    }\r\n\r\n    // =========================================================================\r\n    // ANALYZERS\r\n    // =========================================================================\r\n\r\n    private analyzePageStructure(workflow: WorkflowJSON): OptimizationIssue[] {\r\n        const issues: OptimizationIssue[] = [];\r\n        const pages = workflow.pages || [];\r\n\r\n        pages.forEach((page, index) => {\r\n            const blocks = page.blocks || [];\r\n\r\n            // A. Long Pages\r\n            if (blocks.length > 10) {\r\n                issues.push({\r\n                    id: `long-page-${page.id}`,\r\n                    category: \"page_structure\",\r\n                    severity: \"medium\",\r\n                    title: \"Page is too long\",\r\n                    description: `Page \"${page.title}\" has ${blocks.length} blocks. Consider splitting it.`,\r\n                    location: { pageId: page.id },\r\n                    fixable: true,\r\n                    suggestedFix: {\r\n                        type: \"split_page\",\r\n                        description: \"Split page after 5th block\",\r\n                        payload: { pageId: page.id, splitAtIndex: 5 }\r\n                    }\r\n                });\r\n            }\r\n\r\n            // B. Fragmented Pages (Micro-pages)\r\n            // Ignore if it's a special page or the only page\r\n            if (blocks.length <= 1 && pages.length > 3 && index < pages.length - 1) {\r\n                // Check if next page is also small or if we can merge down\r\n                const nextPage = pages[index + 1];\r\n                issues.push({\r\n                    id: `fragment-page-${page.id}`,\r\n                    category: \"page_structure\",\r\n                    severity: \"low\",\r\n                    title: \"Page is very short\",\r\n                    description: `Page \"${page.title}\" has only ${blocks.length} block(s). Consider merging.`,\r\n                    location: { pageId: page.id },\r\n                    fixable: true,\r\n                    suggestedFix: {\r\n                        type: \"merge_pages\",\r\n                        description: `Merge with next page \"${nextPage.title}\"`,\r\n                        payload: { sourcePageId: page.id, targetPageId: nextPage.id }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        return issues;\r\n    }\r\n\r\n    private analyzeBlockStructure(workflow: WorkflowJSON): OptimizationIssue[] {\r\n        const issues: OptimizationIssue[] = [];\r\n        const blocks = this.getAllBlocks(workflow);\r\n\r\n        // 1. Duplicate Questions (Text matching)\r\n        const titleMap = new Map<string, string[]>(); // Title -> BlockIDs\r\n        blocks.forEach(b => {\r\n            if (b.title && b.type !== 'display') {\r\n                const key = b.title.trim().toLowerCase();\r\n                if (!titleMap.has(key)) { titleMap.set(key, []); }\r\n                titleMap.get(key)!.push(b.id);\r\n            }\r\n        });\r\n\r\n        titleMap.forEach((ids, title) => {\r\n            if (ids.length > 1) {\r\n                issues.push({\r\n                    id: `duplicate-question-${ids[0]}`,\r\n                    category: \"block_structure\",\r\n                    severity: \"medium\",\r\n                    title: \"Duplicate Question Text\",\r\n                    description: `The question \"${title}\" appears ${ids.length} times.`,\r\n                    location: { blockId: ids[0] },\r\n                    fixable: false, // Hard to autofix without knowing intent\r\n                });\r\n            }\r\n        });\r\n\r\n        // 2. Unused Variables\r\n        // (Requires scanning all logic/prefills to see if variable is consumed. Skipping deep scan for MVP)\r\n\r\n        return issues;\r\n    }\r\n\r\n    private analyzeLogic(workflow: WorkflowJSON): OptimizationIssue[] {\r\n        const issues: OptimizationIssue[] = [];\r\n        const blocks = this.getAllBlocks(workflow);\r\n\r\n        blocks.forEach(block => {\r\n            // Check for empty branches or constant conditions\r\n            if (block.visibleIf) {\r\n                const conditionStr = JSON.stringify(block.visibleIf);\r\n                if (conditionStr.includes(\"true\") && conditionStr.length < 20) { // Naive check for \"always true\"\r\n                    issues.push({\r\n                        id: `logic-always-true-${block.id}`,\r\n                        category: \"logic\",\r\n                        severity: \"low\",\r\n                        title: \"Redundant Condition\",\r\n                        description: `Block logic appears to be always true.`,\r\n                        location: { blockId: block.id },\r\n                        fixable: true,\r\n                        suggestedFix: {\r\n                            type: \"simplify_logic\",\r\n                            description: \"Remove condition\",\r\n                            payload: { blockId: block.id, action: \"remove_condition\" }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        });\r\n\r\n        return issues;\r\n    }\r\n\r\n    private generateSuggestions(issues: OptimizationIssue[], _workflow: WorkflowJSON): OptimizationSuggestion[] {\r\n        const suggestions: OptimizationSuggestion[] = [];\r\n\r\n        const longPages = issues.filter(i => i.id.startsWith(\"long-page\"));\r\n        if (longPages.length > 0) {\r\n            suggestions.push({\r\n                id: \"sugg-split-pages\",\r\n                title: \"Improve Mobile Completion\",\r\n                description: `Split ${longPages.length} long pages to reduce scroll depth and improve cognitive load.`,\r\n                impact: \"high\",\r\n                effort: \"low\",\r\n                relatedIssues: longPages.map(i => i.id)\r\n            });\r\n        }\r\n\r\n        const fragments = issues.filter(i => i.id.startsWith(\"fragment\"));\r\n        if (fragments.length > 2) {\r\n            suggestions.push({\r\n                id: \"sugg-consolidate\",\r\n                title: \"Consolidate Structure\",\r\n                description: `Merge ${fragments.length} fragmented pages to reduce click fatigue.`,\r\n                impact: \"medium\",\r\n                effort: \"low\",\r\n                relatedIssues: fragments.map(i => i.id)\r\n            });\r\n        }\r\n\r\n        return suggestions;\r\n    }\r\n\r\n    // =========================================================================\r\n    // FIX APPLIERS\r\n    // =========================================================================\r\n\r\n    private applySplitPage(workflow: WorkflowJSON, payload: { pageId: string, splitAtIndex: number }) {\r\n        const pageIndex = workflow.pages.findIndex(p => p.id === payload.pageId);\r\n        if (pageIndex === -1) { return; }\r\n\r\n        const page = workflow.pages[pageIndex];\r\n        if (payload.splitAtIndex >= page.blocks.length) { return; }\r\n\r\n        const blocksToMove = page.blocks.splice(payload.splitAtIndex);\r\n\r\n        const newPage: WorkflowPage = {\r\n            id: uuidv4(),\r\n            title: `${page.title} (Continued)`,\r\n            blocks: blocksToMove,\r\n            order: page.order + 1 // We'll need to reorder subsequent pages\r\n        };\r\n\r\n        // Insert new page\r\n        workflow.pages.splice(pageIndex + 1, 0, newPage);\r\n\r\n        // Fix orders\r\n        workflow.pages.forEach((p, idx) => { p.order = idx + 1; });\r\n    }\r\n\r\n    private applyMergePages(workflow: WorkflowJSON, payload: { sourcePageId: string, targetPageId: string }) {\r\n        const sourceIdx = workflow.pages.findIndex(p => p.id === payload.sourcePageId);\r\n        const targetIdx = workflow.pages.findIndex(p => p.id === payload.targetPageId);\r\n\r\n        if (sourceIdx === -1 || targetIdx === -1) { return; }\r\n\r\n        const sourcePage = workflow.pages[sourceIdx];\r\n        const targetPage = workflow.pages[targetIdx];\r\n\r\n        // Append blocks to target\r\n        targetPage.blocks.push(...sourcePage.blocks);\r\n\r\n        // Remove source page\r\n        workflow.pages.splice(sourceIdx, 1);\r\n\r\n        // Fix orders\r\n        workflow.pages.forEach((p, idx) => { p.order = idx + 1; });\r\n    }\r\n\r\n    private applyDeleteBlock(workflow: WorkflowJSON, payload: { blockId: string }) {\r\n        for (const page of workflow.pages) {\r\n            const idx = page.blocks.findIndex(b => b.id === payload.blockId);\r\n            if (idx !== -1) {\r\n                page.blocks.splice(idx, 1);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    private applyMoveBlock(workflow: WorkflowJSON, payload: { blockId: string, targetPageId: string, index: number }) {\r\n        let block: WorkflowBlock | undefined;\r\n\r\n        // Find and remove block\r\n        for (const page of workflow.pages) {\r\n            const idx = page.blocks.findIndex(b => b.id === payload.blockId);\r\n            if (idx !== -1) {\r\n                block = page.blocks.splice(idx, 1)[0];\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!block) { return; }\r\n\r\n        // Insert into target\r\n        const targetPage = workflow.pages.find(p => p.id === payload.targetPageId);\r\n        if (targetPage) {\r\n            if (payload.index >= 0 && payload.index <= targetPage.blocks.length) {\r\n                targetPage.blocks.splice(payload.index, 0, block);\r\n            } else {\r\n                targetPage.blocks.push(block);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // =========================================================================\r\n    // HELPER METHODS\r\n    // =========================================================================\r\n\r\n    private calculateMetrics(workflow: WorkflowJSON): WorkflowMetrics {\r\n        const pages = workflow.pages || [];\r\n        const blocks = this.getAllBlocks(workflow);\r\n\r\n        // Simple Cyclomatic Complexity (count branches)\r\n        let complexity = 1;\r\n        blocks.forEach(b => {\r\n            if (b.visibleIf) { complexity++; }\r\n            if (b.type === 'branch') {\r\n                const branches = b.config?.branches || []; // Cast safely\r\n                complexity += branches.length;\r\n            }\r\n        });\r\n\r\n        return {\r\n            totalPages: pages.length,\r\n            totalBlocks: blocks.length,\r\n            avgBlocksPerPage: (pages.length > 0) ? Number((blocks.length / pages.length).toFixed(1)) : 0,\r\n            estimatedCompletionTimeMs: blocks.length * 15000,\r\n            cyclomaticComplexity: complexity,\r\n            unusedVariablesCount: 0, // Not implemented deeply\r\n            readabilityScore: Math.max(0, 100 - (complexity / 2)) // Simple heuristic\r\n        };\r\n    }\r\n\r\n    private calculateScore(issues: OptimizationIssue[], metrics: WorkflowMetrics): number {\r\n        let score = 100;\r\n\r\n        issues.forEach(issue => {\r\n            switch (issue.severity) {\r\n                case \"critical\": score -= 20; break;\r\n                case \"high\": score -= 10; break;\r\n                case \"medium\": score -= 5; break;\r\n                case \"low\": score -= 2; break;\r\n            }\r\n        });\r\n\r\n        // Penalize complexity\r\n        if (metrics.cyclomaticComplexity > 50) { score -= 10; }\r\n\r\n        return Math.max(0, Math.min(100, Math.round(score)));\r\n    }\r\n\r\n    private getAllBlocks(workflow: WorkflowJSON): WorkflowBlock[] {\r\n        let blocks: WorkflowBlock[] = [];\r\n        const pages = workflow.pages || [];\r\n        pages.forEach((p) => {\r\n            if (p.blocks) { blocks = blocks.concat(p.blocks); }\r\n        });\r\n        return blocks;\r\n    }\r\n}\r\n\r\nexport const workflowOptimizationService = new WorkflowOptimizationService();\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\WorkflowRevisionService.ts","messages":[{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":9,"column":5,"nodeType":"ImportSpecifier","endLine":9,"endColumn":18},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":180,"column":34,"nodeType":"ChainExpression","messageId":"conditionErrorNumber","endLine":180,"endColumn":74,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[6768,6808],"text":"((request.currentWorkflow.sections?.length) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[6768,6808],"text":"(!Number.isNaN((request.currentWorkflow.sections?.length)))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6768,6808],"text":"(Boolean((request.currentWorkflow.sections?.length)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":221,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9022,9025],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9022,9025],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .code on an `any` value.","line":223,"column":37,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":223,"endColumn":41},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":227,"column":25,"nodeType":"Property","messageId":"anyAssignment","endLine":227,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .estimatedTokens on an `any` value.","line":227,"column":61,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":227,"endColumn":76},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":228,"column":25,"nodeType":"Property","messageId":"anyAssignment","endLine":228,"endColumn":71},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .responseLength on an `any` value.","line":228,"column":57,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":228,"endColumn":71},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":260,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":260,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10972,10975],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10972,10975],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .code on an `any` value.","line":261,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":261,"endColumn":27},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .estimatedTokens on an `any` value.","line":262,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":262,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .responseLength on an `any` value.","line":263,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":263,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":269,"column":17,"nodeType":"AssignmentExpression","messageId":"anyAssignment","endLine":269,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":270,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":270,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11395,11398],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11395,11398],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":272,"column":23,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":272,"endColumn":81},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":272,"column":39,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":272,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":272,"column":50,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":272,"endColumn":57},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":273,"column":34,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":273,"endColumn":47,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[11569,11582],"text":"(Boolean(positionMatch))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any` assigned to a parameter of type `string`.","line":273,"column":59,"nodeType":"MemberExpression","messageId":"unsafeArgument","endLine":273,"endColumn":75},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access [1] on an `any` value.","line":273,"column":73,"nodeType":"Literal","messageId":"unsafeMemberExpression","endLine":273,"endColumn":74},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":280,"column":21,"nodeType":"Property","messageId":"anyAssignment","endLine":280,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":280,"column":44,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":280,"endColumn":51},{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":318,"column":23,"nodeType":"Identifier","endLine":318,"endColumn":36},{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":325,"column":23,"nodeType":"Identifier","endLine":325,"endColumn":36},{"ruleId":"max-lines-per-function","severity":2,"message":"Async method 'reviseWorkflowChunked' has too many lines (170). Maximum allowed is 150.","line":344,"column":5,"nodeType":"MethodDefinition","messageId":"exceed","endLine":564,"endColumn":6},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 31 to the 15 allowed.","line":344,"column":19,"nodeType":null,"messageId":"refactorFunction","endLine":344,"endColumn":40},{"ruleId":"complexity","severity":2,"message":"Async method 'reviseWorkflowChunked' has a complexity of 25. Maximum allowed is 15.","line":344,"column":40,"nodeType":"FunctionExpression","messageId":"complex","endLine":564,"endColumn":6},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":350,"column":26,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":350,"endColumn":43},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":382,"column":55,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":382,"endColumn":62},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":440,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":440,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19742,19745],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19742,19745],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":483,"column":21,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":483,"endColumn":57},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":493,"column":37,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":493,"endColumn":62},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":494,"column":66,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":494,"endColumn":68,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[22466,22468],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":495,"column":65,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":495,"endColumn":67,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[22539,22541],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":499,"column":42,"nodeType":"ChainExpression","messageId":"conditionErrorNumber","endLine":499,"endColumn":86,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[22653,22697],"text":"((chunkResult.updatedWorkflow.sections?.length) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[22653,22697],"text":"(!Number.isNaN((chunkResult.updatedWorkflow.sections?.length)))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[22653,22697],"text":"(Boolean((chunkResult.updatedWorkflow.sections?.length)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":500,"column":35,"nodeType":"ChainExpression","messageId":"conditionErrorNumber","endLine":500,"endColumn":67,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[22738,22770],"text":"((chunkResult.diff?.changes.length) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[22738,22770],"text":"(!Number.isNaN((chunkResult.diff?.changes.length)))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[22738,22770],"text":"(Boolean((chunkResult.diff?.changes.length)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":536,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":536,"endColumn":44},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":537,"column":30,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":537,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of type `any[]` to a variable of type `{ type: \"remove\" | \"add\" | \"update\" | \"move\"; target: string; before?: any; after?: any; explanation?: string | undefined; }[]`.","line":553,"column":17,"nodeType":"Property","messageId":"unsafeAssignment","endLine":553,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":606,"column":19,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":606,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":608,"column":17,"nodeType":"Property","messageId":"anyAssignment","endLine":608,"endColumn":69},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":608,"column":34,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":608,"endColumn":64,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[27237,27267],"text":"(Boolean((structureData.sections?.length)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sections on an `any` value.","line":608,"column":48,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":608,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":614,"column":17,"nodeType":"Property","messageId":"anyAssignment","endLine":620,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":614,"column":27,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":614,"endColumn":61},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":614,"column":28,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":614,"endColumn":50,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[27580,27602],"text":"(Boolean(structureData.sections))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sections on an `any` value.","line":614,"column":42,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":614,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":614,"column":58,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":614,"endColumn":61},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":614,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":614,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27618,27621],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27618,27621],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":616,"column":21,"nodeType":"Property","messageId":"anyAssignment","endLine":616,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .title on an `any` value.","line":616,"column":30,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":616,"endColumn":35},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":617,"column":21,"nodeType":"Property","messageId":"anyAssignment","endLine":617,"endColumn":55},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":617,"column":34,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":617,"endColumn":47,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[27757,27770],"text":"(Boolean(s.description))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .description on an `any` value.","line":617,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":617,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":629,"column":17,"nodeType":"Property","messageId":"anyAssignment","endLine":629,"endColumn":70},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .length on an `any` value.","line":629,"column":64,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":629,"endColumn":70},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":636,"column":36,"nodeType":"ChainExpression","messageId":"conditionErrorNumber","endLine":636,"endColumn":75,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[28748,28787],"text":"((result.updatedWorkflow.sections?.length) !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[28748,28787],"text":"(!Number.isNaN((result.updatedWorkflow.sections?.length)))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[28748,28787],"text":"(Boolean((result.updatedWorkflow.sections?.length)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":642,"column":40,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":642,"endColumn":70,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[29043,29073],"text":"(Boolean((structureData.sections?.length)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .sections on an `any` value.","line":642,"column":54,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":642,"endColumn":62},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":644,"column":44,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":644,"endColumn":46,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[29197,29199],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":647,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":647,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29263,29266],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29263,29266],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":652,"column":21,"nodeType":"Property","messageId":"anyAssignment","endLine":652,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .message on an `any` value.","line":652,"column":36,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":652,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":653,"column":21,"nodeType":"Property","messageId":"anyAssignment","endLine":653,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .code on an `any` value.","line":653,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":653,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":654,"column":21,"nodeType":"Property","messageId":"anyAssignment","endLine":654,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .stack on an `any` value.","line":654,"column":34,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":654,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":655,"column":21,"nodeType":"Property","messageId":"anyAssignment","endLine":655,"endColumn":37},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":655,"column":33,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":655,"endColumn":37}],"suppressedMessages":[],"errorCount":66,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n    AIWorkflowRevisionResponseSchema,\n} from '../../../shared/types/ai';\nimport { createLogger } from '../../logger';\n\nimport { AIPromptBuilder } from './AIPromptBuilder';\nimport { AIProviderClient } from './AIProviderClient';\nimport {\n    createAIError,\n    estimateTokenCount,\n    isResponseTruncated,\n    validateWorkflowStructure\n} from './AIServiceUtils';\n\nimport type {\n    AIWorkflowRevisionRequest,\n    AIWorkflowRevisionResponse,\n    AIGeneratedSection,\n} from '../../../shared/types/ai';\nconst logger = createLogger({ module: 'workflow-revision-service' });\n\n/**\n * Represents a chunk of sections for semantic chunking\n */\ninterface SectionChunk {\n    /** Indices of sections in this chunk (relative to original sections array) */\n    sectionIndices: number[];\n    /** Estimated token count for this chunk */\n    estimatedTokens: number;\n    /** Whether any section in this chunk was split (exceeds limit alone) */\n    containsSplitSection: boolean;\n}\nexport class WorkflowRevisionService {\n    private client: AIProviderClient;\n    private promptBuilder: AIPromptBuilder;\n    constructor(client: AIProviderClient, promptBuilder: AIPromptBuilder) {\n        this.client = client;\n        this.promptBuilder = promptBuilder;\n    }\n\n    /**\n     * Semantic section-aware chunking for large workflows\n     *\n     * Groups sections into chunks that respect section boundaries:\n     * - Never splits a section unless it alone exceeds the token limit\n     * - Keeps logically related sections together when possible\n     * - Returns chunks as arrays of section indices for proper tracking\n     *\n     * @param sections - Array of workflow sections\n     * @param maxTokensPerChunk - Maximum tokens allowed per chunk (output estimate)\n     * @param outputMultiplier - Multiplier for estimating output tokens (default 2x input)\n     * @returns Array of SectionChunk objects with section indices and metadata\n     */\n    private chunkWorkflowBySections(\n        sections: AIGeneratedSection[],\n        maxTokensPerChunk: number = 6400,\n        outputMultiplier: number = 2,\n    ): SectionChunk[] {\n        if (sections.length === 0) {\n            return [];\n        }\n\n        // Calculate token count for each section\n        const sectionTokens = sections.map((section, index) => {\n            const sectionJson = JSON.stringify(section);\n            const inputTokens = estimateTokenCount(sectionJson);\n            const estimatedOutputTokens = inputTokens * outputMultiplier;\n            return {\n                index,\n                inputTokens,\n                estimatedOutputTokens,\n                section,\n            };\n        });\n\n        logger.debug({\n            sectionCount: sections.length,\n            maxTokensPerChunk,\n            sectionSizes: sectionTokens.map(s => ({\n                index: s.index,\n                title: s.section.title,\n                estimatedOutputTokens: s.estimatedOutputTokens,\n            })),\n        }, 'Section token analysis for semantic chunking');\n\n        const chunks: SectionChunk[] = [];\n        let currentChunk: SectionChunk = {\n            sectionIndices: [],\n            estimatedTokens: 0,\n            containsSplitSection: false,\n        };\n\n        for (const sectionData of sectionTokens) {\n            const { index, estimatedOutputTokens, section } = sectionData;\n\n            // Check if this single section exceeds the limit\n            if (estimatedOutputTokens > maxTokensPerChunk) {\n                // Finish current chunk if it has content\n                if (currentChunk.sectionIndices.length > 0) {\n                    chunks.push(currentChunk);\n                    currentChunk = {\n                        sectionIndices: [],\n                        estimatedTokens: 0,\n                        containsSplitSection: false,\n                    };\n                }\n\n                // This section alone exceeds the limit - it gets its own chunk\n                // Mark it as containing a \"split section\" for special handling\n                logger.warn({\n                    sectionIndex: index,\n                    sectionTitle: section.title,\n                    estimatedOutputTokens,\n                    maxTokensPerChunk,\n                }, 'Section exceeds token limit - will be processed alone');\n\n                chunks.push({\n                    sectionIndices: [index],\n                    estimatedTokens: estimatedOutputTokens,\n                    containsSplitSection: true,\n                });\n                continue;\n            }\n\n            // Check if adding this section would exceed the chunk limit\n            if (currentChunk.estimatedTokens + estimatedOutputTokens > maxTokensPerChunk) {\n                // Start a new chunk (don't split the section)\n                if (currentChunk.sectionIndices.length > 0) {\n                    chunks.push(currentChunk);\n                }\n                currentChunk = {\n                    sectionIndices: [index],\n                    estimatedTokens: estimatedOutputTokens,\n                    containsSplitSection: false,\n                };\n            } else {\n                // Add to current chunk\n                currentChunk.sectionIndices.push(index);\n                currentChunk.estimatedTokens += estimatedOutputTokens;\n            }\n        }\n\n        // Don't forget the last chunk\n        if (currentChunk.sectionIndices.length > 0) {\n            chunks.push(currentChunk);\n        }\n\n        logger.info({\n            totalSections: sections.length,\n            totalChunks: chunks.length,\n            chunkDetails: chunks.map((chunk, i) => ({\n                chunkIndex: i,\n                sectionIndices: chunk.sectionIndices,\n                sectionTitles: chunk.sectionIndices.map(idx => sections[idx].title),\n                estimatedTokens: chunk.estimatedTokens,\n                containsSplitSection: chunk.containsSplitSection,\n            })),\n        }, 'Semantic chunking complete');\n\n        return chunks;\n    }\n\n    /**\n     * Revise an existing workflow based on user instructions\n     * Automatically chunks large workflows to avoid token limits\n     *\n     * Enhanced with automatic retry logic:\n     * - Tries single-shot first for speed\n     * - Detects truncation and automatically retries with chunking\n     * - Handles workflows up to 10x larger than before\n     */\n    async reviseWorkflow(\n        request: AIWorkflowRevisionRequest,\n    ): Promise<AIWorkflowRevisionResponse> {\n        const startTime = Date.now();\n        try {\n            // Estimate token count of the full workflow\n            const workflowJson = JSON.stringify(request.currentWorkflow);\n            const estimatedInputTokens = estimateTokenCount(workflowJson);\n            const sectionCount = request.currentWorkflow.sections?.length || 0;\n            // Estimate output size based on input\n            // Large workflows typically generate 1.5-2x tokens in output\n            const estimatedOutputTokens = estimatedInputTokens * 2;\n            // Token threshold for chunking (leave headroom for prompt + response)\n            // INPUT threshold: If workflow itself is > 2500 tokens, chunk proactively\n            // OUTPUT threshold: If estimated output > 6000 tokens, chunk proactively\n            const INPUT_CHUNK_THRESHOLD = 2500;\n            const OUTPUT_CHUNK_THRESHOLD = 6000;\n            const shouldChunkProactively =\n                estimatedInputTokens > INPUT_CHUNK_THRESHOLD ||\n                estimatedOutputTokens > OUTPUT_CHUNK_THRESHOLD ||\n                sectionCount > 15;  // More than 15 sections = chunk\n            logger.debug({\n                estimatedInputTokens,\n                estimatedOutputTokens,\n                sectionCount,\n                shouldChunkProactively,\n                inputThreshold: INPUT_CHUNK_THRESHOLD,\n                outputThreshold: OUTPUT_CHUNK_THRESHOLD,\n            }, 'Workflow revision token estimation');\n            // If workflow is large enough to warrant chunking, use chunked revision immediately\n            if (shouldChunkProactively) {\n                logger.info({\n                    estimatedInputTokens,\n                    estimatedOutputTokens,\n                    sectionCount,\n                    reason: estimatedInputTokens > INPUT_CHUNK_THRESHOLD ? 'large_input' :\n                        estimatedOutputTokens > OUTPUT_CHUNK_THRESHOLD ? 'large_output' :\n                            'many_sections',\n                }, 'Workflow large enough to warrant chunking - using chunked revision');\n                return await this.reviseWorkflowChunked(request);\n            }\n            // Otherwise, try single-shot first (faster)\n            try {\n                logger.info({\n                    estimatedInputTokens,\n                    estimatedOutputTokens,\n                    sectionCount,\n                }, 'Attempting single-shot workflow revision');\n                return await this.reviseWorkflowSingleShot(request);\n            } catch (singleShotError: any) {\n                // If single-shot fails due to truncation, automatically retry with chunking\n                if (singleShotError.code === 'RESPONSE_TRUNCATED') {\n                    logger.warn({\n                        estimatedInputTokens,\n                        estimatedOutputTokens,\n                        actualOutputTokens: singleShotError.estimatedTokens,\n                        responseLength: singleShotError.responseLength,\n                    }, 'Single-shot revision truncated - automatically retrying with chunking');\n                    return await this.reviseWorkflowChunked(request);\n                }\n                // For other errors, re-throw\n                throw singleShotError;\n            }\n        } catch (error) {\n            const duration = Date.now() - startTime;\n            logger.error({ duration, error }, 'AI workflow revision failed');\n            throw error;\n        }\n    }\n    /**\n     * Single-shot workflow revision (original implementation)\n     */\n    private async reviseWorkflowSingleShot(\n        request: AIWorkflowRevisionRequest,\n    ): Promise<AIWorkflowRevisionResponse> {\n        const startTime = Date.now();\n        try {\n            const prompt = this.buildWorkflowRevisionPrompt(request);\n            const response = await this.client.callLLM(prompt, 'workflow_revision');\n            // FIRST: Check for truncation BEFORE attempting to parse\n            if (isResponseTruncated(response)) {\n                const estimatedTokens = estimateTokenCount(response);\n                logger.error({\n                    responseLength: response.length,\n                    estimatedTokens,\n                    responseSuffix: response.substring(Math.max(0, response.length - 500)),\n                }, 'Detected truncated AI response - workflow too large for single-shot revision');\n                // Throw specific error that will trigger chunking retry\n                const error: any = new Error('Response truncated - workflow too large');\n                error.code = 'RESPONSE_TRUNCATED';\n                error.estimatedTokens = estimatedTokens;\n                error.responseLength = response.length;\n                throw error;\n            }\n            // Parse and validate\n            let parsed;\n            try {\n                parsed = JSON.parse(response);\n            } catch (parseError: any) {\n                // Extract position info from error\n                const positionMatch = parseError.message.match(/position (\\d+)/);\n                const position = positionMatch ? parseInt(positionMatch[1]) : 0;\n                // Get context around the error position\n                const contextStart = Math.max(0, position - 200);\n                const contextEnd = Math.min(response.length, position + 200);\n                const errorContext = response.substring(contextStart, contextEnd);\n                // Log the actual response for debugging\n                logger.error({\n                    parseError: parseError.message,\n                    responseLength: response.length,\n                    responsePreview: response.substring(0, 500),\n                    responseSuffix: response.substring(Math.max(0, response.length - 500)),\n                    errorPosition: position,\n                    errorContext: errorContext,\n                    errorContextStart: contextStart,\n                }, 'Failed to parse AI response as JSON');\n                // Write full response to file for debugging\n                const fs = await import('fs');\n                const path = await import('path');\n                const debugPath = path.join(process.cwd(), 'logs', `ai-response-error-${Date.now()}.json`);\n                try {\n                    if (!fs.existsSync(path.dirname(debugPath))) {\n                        await fs.promises.mkdir(path.dirname(debugPath), { recursive: true });\n                    }\n                    await fs.promises.writeFile(debugPath, response);\n                    logger.error({ debugPath }, 'Full AI response written to file for debugging');\n                } catch (fsError) {\n                    logger.error({ fsError }, 'Failed to write debug file');\n                }\n                // Re-throw parse error (truncation should have been caught above)\n                throw parseError;\n            }\n            const validated = AIWorkflowRevisionResponseSchema.parse(parsed);\n            // Validate structure of generated workflow\n            validateWorkflowStructure(validated.updatedWorkflow);\n            const duration = Date.now() - startTime;\n            logger.info({\n                duration,\n                workflowId: request.workflowId,\n                changeCount: validated.diff.changes.length,\n            }, 'AI workflow revision succeeded');\n            return validated;\n        } catch (error) {\n            const duration = Date.now() - startTime;\n            logger.error({ error, duration }, 'AI workflow revision failed');\n            if (error instanceof SyntaxError) {\n                throw createAIError(\n                    'Failed to parse AI response as JSON',\n                    'INVALID_RESPONSE',\n                    { originalError: error.message },\n                );\n            }\n            if (error instanceof Error && error.name === 'ZodError') {\n                throw createAIError(\n                    'AI response does not match expected schema',\n                    'VALIDATION_ERROR',\n                    { originalError: error },\n                );\n            }\n            throw error;\n        }\n    }\n    /**\n     * Chunked workflow revision for large workflows\n     * Breaks workflow into section groups and processes them independently\n     *\n     * Enhanced chunking strategy:\n     * - Dynamically calculates chunk size based on output token limits\n     * - Handles workflows 10x larger than before\n     * - Better progress tracking and error recovery\n     * - Special handling for single massive sections\n     */\n    private async reviseWorkflowChunked(\n        request: AIWorkflowRevisionRequest,\n        skipTwoPassStrategy = false,  // Prevent infinite recursion\n    ): Promise<AIWorkflowRevisionResponse> {\n        const startTime = Date.now();\n        const workflow = request.currentWorkflow;\n        const sections = workflow.sections || [];\n        if (sections.length === 0) {\n            // No sections to chunk, fall back to single shot\n            return this.reviseWorkflowSingleShot(request);\n        }\n        // EDGE CASE: Single massive section that's too large\n        // Chunking by sections won't help - need different strategy\n        if (sections.length === 1 && !skipTwoPassStrategy) {\n            // Check BOTH the current section size AND the instruction size\n            // (instruction often contains the document content)\n            const singleSectionSize = estimateTokenCount(JSON.stringify(sections[0]));\n            const instructionSize = estimateTokenCount(request.userInstruction);\n            // Use the larger of the two to estimate output\n            const largerInputSize = Math.max(singleSectionSize, instructionSize);\n            const estimatedOutputSize = largerInputSize * 2;\n            if (estimatedOutputSize > 6000) {\n                logger.warn({\n                    sectionSize: singleSectionSize,\n                    instructionSize,\n                    largerInputSize,\n                    estimatedOutputSize,\n                }, 'Single section with large content - using two-pass revision strategy');\n                // Strategy: Ask AI to create a simplified structure first, then fill details\n                return this.reviseWorkflowInPasses(request);\n            }\n        }\n        logger.info({\n            totalSections: sections.length,\n            instruction: request.userInstruction,\n        }, 'Starting chunked workflow revision with semantic section-aware chunking');\n\n        // Check if sections are mostly empty (e.g., from Pass 1 of two-pass strategy)\n        const hasEmptySections = sections.every(s => !s.steps || s.steps.length === 0);\n\n        // Determine output multiplier based on content type\n        // Empty sections being filled from large instruction need higher multiplier\n        let outputMultiplier = 2;  // Default: output ~2x input\n        let maxTokensPerChunk = 6400;  // 80% of 8K limit\n\n        if (hasEmptySections && request.userInstruction) {\n            // Empty sections being filled from large instruction (like PDF content)\n            // Use higher multiplier as each section will generate substantial content\n            const instructionSize = estimateTokenCount(request.userInstruction);\n            outputMultiplier = instructionSize > 3000 ? 6 : 4;\n\n            // For very large instructions, reduce chunk size further\n            if (instructionSize > 5000) {\n                maxTokensPerChunk = 3200;  // More aggressive chunking\n            } else if (instructionSize > 3000) {\n                maxTokensPerChunk = 4800;\n            }\n\n            logger.info({\n                instructionSize,\n                outputMultiplier,\n                maxTokensPerChunk,\n            }, 'Adjusted chunking parameters for empty sections with large instruction');\n        }\n\n        // Use semantic section-aware chunking\n        const sectionChunks = this.chunkWorkflowBySections(\n            sections,\n            maxTokensPerChunk,\n            outputMultiplier,\n        );\n\n        // Convert SectionChunk objects to actual section arrays for processing\n        const chunks: { sections: typeof sections; chunkMeta: SectionChunk }[] = sectionChunks.map(chunk => ({\n            sections: chunk.sectionIndices.map(idx => sections[idx]),\n            chunkMeta: chunk,\n        }));\n\n        logger.info({\n            totalSections: sections.length,\n            chunksCount: chunks.length,\n            hasEmptySections,\n            outputMultiplier,\n            maxTokensPerChunk,\n            chunkSummary: chunks.map((c, i) => ({\n                chunk: i + 1,\n                sectionCount: c.sections.length,\n                sectionIndices: c.chunkMeta.sectionIndices,\n                estimatedTokens: c.chunkMeta.estimatedTokens,\n                containsSplitSection: c.chunkMeta.containsSplitSection,\n            })),\n        }, 'Semantic chunking complete - ready for processing');\n        // Process chunks sequentially (to maintain context and order)\n        // We could do parallel, but sequential gives better context awareness\n        // Track revised sections by their original index for proper ordering\n        const revisedSectionsByIndex: Map<number, typeof sections[0]> = new Map();\n        const allChanges: any[] = [];\n        const allExplanations: string[] = [];\n        const allSuggestions: string[] = [];\n\n        for (let i = 0; i < chunks.length; i++) {\n            const { sections: chunkSections, chunkMeta } = chunks[i];\n            const chunkNumber = i + 1;\n\n            logger.info({\n                chunkNumber,\n                totalChunks: chunks.length,\n                sectionCount: chunkSections.length,\n                sectionIndices: chunkMeta.sectionIndices,\n                sectionTitles: chunkSections.map(s => s.title),\n                containsSplitSection: chunkMeta.containsSplitSection,\n                estimatedTokens: chunkMeta.estimatedTokens,\n            }, `Processing chunk ${chunkNumber}/${chunks.length} (semantic chunking)`);\n\n            try {\n                // Create a mini-workflow with just this chunk's sections\n                const chunkWorkflow = {\n                    ...workflow,\n                    sections: chunkSections,\n                };\n\n                // Build context about which sections are in this chunk\n                const sectionRange = chunkMeta.sectionIndices.length === 1\n                    ? `section ${chunkMeta.sectionIndices[0] + 1}`\n                    : `sections ${chunkMeta.sectionIndices[0] + 1}-${chunkMeta.sectionIndices[chunkMeta.sectionIndices.length - 1] + 1}`;\n\n                // Create chunk-specific request with context about other chunks\n                const chunkRequest: AIWorkflowRevisionRequest = {\n                    ...request,\n                    currentWorkflow: chunkWorkflow,\n                    userInstruction: `${request.userInstruction}\n\nIMPORTANT CONTEXT: You are processing ${sectionRange} out of ${sections.length} total sections in this workflow. Focus your revisions on these sections only. Other sections will be processed separately.\nSection titles in this chunk: ${chunkSections.map(s => s.title).join(', ')}`,\n                };\n\n                const chunkResult = await this.reviseWorkflowSingleShot(chunkRequest);\n\n                // Map revised sections back to their original indices\n                if (chunkResult.updatedWorkflow.sections) {\n                    chunkResult.updatedWorkflow.sections.forEach((revisedSection, idx) => {\n                        const originalIndex = chunkMeta.sectionIndices[idx];\n                        if (originalIndex !== undefined) {\n                            revisedSectionsByIndex.set(originalIndex, revisedSection);\n                        }\n                    });\n                }\n\n                // Collect changes and metadata\n                allChanges.push(...(chunkResult.diff?.changes || []));\n                allExplanations.push(...(chunkResult.explanation || []));\n                allSuggestions.push(...(chunkResult.suggestions || []));\n\n                logger.info({\n                    chunkNumber,\n                    revisedSectionCount: chunkResult.updatedWorkflow.sections?.length || 0,\n                    changesCount: chunkResult.diff?.changes.length || 0,\n                    mappedIndices: chunkMeta.sectionIndices,\n                }, `Chunk ${chunkNumber}/${chunks.length} completed`);\n            } catch (error) {\n                logger.error({\n                    chunkNumber,\n                    totalChunks: chunks.length,\n                    sectionIndices: chunkMeta.sectionIndices,\n                    error,\n                }, `Failed to process chunk ${chunkNumber}, keeping original sections`);\n\n                // On error, keep original sections for this chunk\n                chunkMeta.sectionIndices.forEach((originalIndex, idx) => {\n                    revisedSectionsByIndex.set(originalIndex, chunkSections[idx]);\n                });\n            }\n        }\n\n        // Reconstruct sections array in original order\n        const revisedSections: typeof sections = [];\n        for (let i = 0; i < sections.length; i++) {\n            const revisedSection = revisedSectionsByIndex.get(i);\n            if (revisedSection) {\n                revisedSections.push(revisedSection);\n            } else {\n                // Fallback: use original section if somehow missing\n                logger.warn({ sectionIndex: i }, 'Section missing from revised map, using original');\n                revisedSections.push(sections[i]);\n            }\n        }\n        // Merge results back together\n        const mergedWorkflow = {\n            ...workflow,\n            sections: revisedSections,\n            // Preserve original logic rules and transform blocks\n            // (chunking doesn't modify these - only sections)\n            logicRules: workflow.logicRules || [],\n            transformBlocks: workflow.transformBlocks || [],\n        };\n        const duration = Date.now() - startTime;\n        logger.info({\n            duration,\n            totalChunks: chunks.length,\n            originalSections: sections.length,\n            revisedSections: revisedSections.length,\n            totalChanges: allChanges.length,\n        }, 'Chunked workflow revision completed');\n        // Count how many chunks contained oversized sections\n        const oversizedChunks = chunks.filter(c => c.chunkMeta.containsSplitSection).length;\n\n        return {\n            updatedWorkflow: mergedWorkflow,\n            diff: {\n                changes: allChanges,\n            },\n            explanation: [\n                `Large workflow processed using semantic section-aware chunking (${chunks.length} chunks)`,\n                ...(oversizedChunks > 0\n                    ? [`Note: ${oversizedChunks} section(s) exceeded token limits and were processed individually`]\n                    : []),\n                ...allExplanations,\n            ],\n            suggestions: [...new Set(allSuggestions)], // Deduplicate suggestions\n        };\n    }\n    /**\n     * Two-pass workflow revision for single massive sections\n     * Pass 1: Create structure (section titles only)\n     * Pass 2: Fill in details (steps for each section)\n     */\n    private async reviseWorkflowInPasses(\n        request: AIWorkflowRevisionRequest,\n    ): Promise<AIWorkflowRevisionResponse> {\n        const startTime = Date.now();\n        logger.info({\n            instruction: request.userInstruction,\n        }, 'Starting two-pass workflow revision for massive section');\n        // PASS 1: Create high-level structure (sections with titles only)\n        const structurePrompt = `You are a VaultLogic Workflow Architect.\nYour task is to analyze the document and create a HIGH-LEVEL STRUCTURE ONLY.\nDocument Content:\n${request.userInstruction}\nIMPORTANT: DO NOT create detailed steps yet. Only create section structure.\nOutput a JSON object with this structure:\n{\n  \"sections\": [\n    {\n      \"title\": \"Section 1 Title\",\n      \"description\": \"What this section covers\"\n    },\n    {\n      \"title\": \"Section 2 Title\",\n      \"description\": \"What this section covers\"\n    }\n  ],\n  \"notes\": \"Brief overview of the workflow structure\"\n}\nRequirements:\n- Create 5-15 logical sections that break down the document\n- Each section should cover a distinct part of the document\n- Keep descriptions brief (1-2 sentences)\n- Output ONLY valid JSON, no markdown\nOutput ONLY the JSON object.`;\n        try {\n            // Get structure from AI\n            const structureResponse = await this.client.callLLM(structurePrompt, 'workflow_revision');\n            const structureData = JSON.parse(structureResponse);\n            logger.info({\n                sectionsCreated: structureData.sections?.length || 0,\n            }, 'Pass 1 completed - structure created');\n            // PASS 2: Create a simplified workflow with the structure\n            // Then use normal chunked revision to fill in details\n            const structuredWorkflow = {\n                ...request.currentWorkflow,\n                sections: (structureData.sections || []).map((s: any, idx: number) => ({\n                    id: `section-${idx + 1}`,\n                    title: s.title,\n                    description: s.description || null,\n                    order: idx,\n                    steps: [], // Empty - will be filled by chunked revision\n                })),\n            };\n            // Now use chunked revision with the structured workflow\n            const structuredRequest = {\n                ...request,\n                currentWorkflow: structuredWorkflow,\n                userInstruction: `${request.userInstruction}\\n\\nIMPORTANT: Fill in detailed steps for each section based on the document content.`,\n            };\n            logger.info({\n                sectionsToProcess: structuredWorkflow.sections.length,\n            }, 'Pass 2 starting - filling section details with chunking');\n            // Use the existing chunked logic with recursion prevention\n            const result = await this.reviseWorkflowChunked(structuredRequest, true);\n            const duration = Date.now() - startTime;\n            logger.info({\n                duration,\n                sectionsProcessed: result.updatedWorkflow.sections?.length || 0,\n            }, 'Two-pass workflow revision completed');\n            return {\n                ...result,\n                explanation: [\n                    ` Processed large document using two-pass strategy:`,\n                    `Pass 1: Created ${structureData.sections?.length || 0} sections`,\n                    `Pass 2: Filled details for each section`,\n                    ...(result.explanation || []),\n                ],\n            };\n        } catch (error: any) {\n            const duration = Date.now() - startTime;\n            logger.error({\n                duration,\n                error: {\n                    message: error.message,\n                    code: error.code,\n                    stack: error.stack,\n                    name: error.name,\n                },\n            }, 'Two-pass workflow revision failed');\n            throw error;\n        }\n    }\n    /**\n     * Build prompt for workflow revision\n     */\n    private buildWorkflowRevisionPrompt(\n        request: AIWorkflowRevisionRequest,\n    ): string {\n        return `You are a VaultLogic Workflow Revision Engine.\nYour task is to modify the Current Workflow based on the User Instruction and Conversation History.\nCurrent Workflow JSON:\n${JSON.stringify(request.currentWorkflow, null, 2)}\nUser Instruction: \"${request.userInstruction}\"\nConversation History:\n${request.conversationHistory ? request.conversationHistory.map(m => `${m.role.toUpperCase()}: ${m.content}`).join('\\n') : 'None'}\nMode: ${request.mode} (Respect constraints of this mode)\nOutput a JSON object with this exact structure:\n{\n  \"updatedWorkflow\": {\n    \"title\": \"Workflow Title\",\n    \"description\": \"Description\",\n    \"sections\": [\n      {\n        \"id\": \"section-1\",\n        \"title\": \"Section Title\",\n        \"description\": null,\n        \"order\": 0,\n        \"steps\": [\n          {\n            \"id\": \"step-1\",\n            \"type\": \"short_text\",\n            \"title\": \"What is your name?\",  // REQUIRED - question text\n            \"description\": null,\n            \"alias\": \"name\",\n            \"required\": true,\n            \"config\": {}\n          }\n        ]\n      }\n    ],\n    \"logicRules\": [\n      {\n        \"id\": \"rule-1\",\n        \"conditionStepAlias\": \"step_alias\",  // REQUIRED - alias of step to check\n        \"operator\": \"equals\",  // REQUIRED - use: equals, not_equals, contains, greater_than, less_than, is_empty, etc. (never use \"is\")\n        \"value\": \"some value\",  // Value to compare against\n        \"targetType\": \"step\",  // REQUIRED - \"step\" or \"section\"\n        \"targetAlias\": \"other_step\",  // REQUIRED - alias of step/section to affect\n        \"action\": \"show\",  // REQUIRED - \"show\", \"hide\", \"require\", \"make_optional\", or \"skip_to\"\n        \"description\": \"Show other_step if step_alias equals 'some value'\"\n      }\n    ],\n    \"transformBlocks\": [],\n    \"notes\": null\n  },\n  \"diff\": {\n    \"changes\": [\n      {\n        \"type\": \"add|remove|update|move\",\n        \"target\": \"path.to.element\",\n        \"before\": null,\n        \"after\": { ... },\n        \"explanation\": \"Added a new specific question\"\n      }\n    ]\n  },\n  \"explanation\": [\"Point 1 about what changed\", \"Point 2\"],\n  \"suggestions\": [\"Follow-up suggestion 1\"]\n}\nCRITICAL REQUIREMENTS:\n    1. **FULL RESPONSE REQUIRED**: You MUST return the ENTIRE workflow structure in 'updatedWorkflow', including ALL existing sections and steps that you did not change.\n    2. **DELETION WARNING**: Any section or step that is missing from your 'updatedWorkflow' will be PERMANENTLY DELETED. Do not be lazy.\n    3. **TITLES**: Every step MUST have a \"title\" field.\n    4. **IDS**: Preserve existing IDs. Generate new UUIDs for new items.\n    5. **CONTENT GENERATION**: If the User Instruction asks to \"build\", \"create\", or \"automate\" a form/workflow, and the current workflow has few or no questions, you MUST generate the full structure (multiple sections, relevant questions). DO NOT just update the title. YOU MUST BUILD THE CONTENT.\n    6. **ALIASES**: Every step MUST have a unique \"alias\" in camelCase (e.g., \"firstName\", \"driverLicenseNumber\"). Do not leave it null or empty.\n    Valid Step Types:\n    - Text: \"short_text\", \"long_text\", \"email\", \"phone\", \"website\", \"number\", \"currency\"\n    - Choice: \"radio\", \"multiple_choice\", \"yes_no\"\n    - Date: \"date\", \"time\", \"date_time\"\n    - Other: \"scale\", \"address\", \"file_upload\", \"display\", \"signature_block\"\n    Output ONLY the JSON object.`;\n    }\n}\n// Singleton export removed - services create their own instances via dependency injection","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\WorkflowSuggestionService.ts","messages":[{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":16,"column":10,"nodeType":"ImportSpecifier","endLine":16,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":32,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1002,1005],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1002,1005],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1035,1038],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1035,1038],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1073,1076],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1073,1076],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":46,"column":19,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":46,"endColumn":48},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2119,2122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2119,2122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":64,"column":28,"nodeType":"Property","messageId":"anyAssignment","endLine":64,"endColumn":33},{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":67,"column":23,"nodeType":"Identifier","endLine":67,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":74,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":74,"endColumn":27},{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":75,"column":23,"nodeType":"Identifier","endLine":75,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":78,"column":23,"nodeType":"Property","messageId":"anyAssignment","endLine":78,"endColumn":43},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":108,"column":19,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":108,"endColumn":48},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected object value in conditional. The condition is always true.","line":121,"column":32,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":121,"endColumn":50},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":136,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4909,4912],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4909,4912],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":138,"column":28,"nodeType":"Property","messageId":"anyAssignment","endLine":138,"endColumn":33},{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":141,"column":23,"nodeType":"Identifier","endLine":141,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .name on an `any` value.","line":148,"column":23,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":148,"endColumn":27},{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":149,"column":23,"nodeType":"Identifier","endLine":149,"endColumn":36},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":152,"column":23,"nodeType":"Property","messageId":"anyAssignment","endLine":152,"endColumn":43},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":242,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8980,8983],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8980,8983],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":250,"column":19,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":250,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of an `any` typed value.","line":262,"column":13,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":262,"endColumn":44},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":262,"column":20,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":262,"endColumn":33,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[9628,9641],"text":"(Boolean(parsed.values))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .values on an `any` value.","line":262,"column":27,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":262,"endColumn":33},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":263,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":263,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9678,9681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9678,9681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":265,"column":28,"nodeType":"Property","messageId":"anyAssignment","endLine":265,"endColumn":33},{"ruleId":"import/no-deprecated","severity":1,"message":"Deprecated: Use AIError class directly or import createAIError from AIError.ts","line":268,"column":23,"nodeType":"Identifier","endLine":268,"endColumn":36}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport {\r\n    AIWorkflowSuggestionSchema,\r\n    AITemplateBindingsResponseSchema,\r\n    AIWorkflowSuggestionRequest,\r\n    AIWorkflowSuggestion,\r\n    AITemplateBindingsRequest,\r\n    AITemplateBindingsResponse,\r\n    AIBindingSuggestion,\r\n} from '../../../shared/types/ai';\r\nimport { createLogger } from '../../logger';\nimport { AliasResolver, WorkflowWithAliases } from '../AliasResolver';\n\r\nimport { AIPromptBuilder } from './AIPromptBuilder';\r\nimport { AIProviderClient } from './AIProviderClient';\r\nimport { createAIError } from './AIServiceUtils';\r\n\r\nconst logger = createLogger({ module: 'workflow-suggestion-service' });\r\n\r\nexport class WorkflowSuggestionService {\r\n    constructor(\r\n        private client: AIProviderClient,\r\n        private promptBuilder: AIPromptBuilder,\r\n    ) { }\r\n\r\n    /**\r\n     * Suggest improvements to an existing workflow\r\n     */\r\n    async suggestWorkflowImprovements(\r\n        request: AIWorkflowSuggestionRequest,\r\n        existingWorkflow: {\r\n            sections: any[];\r\n            logicRules?: any[];\r\n            transformBlocks?: any[];\r\n        },\r\n    ): Promise<AIWorkflowSuggestion> {\r\n        const startTime = Date.now();\r\n\r\n        try {\r\n            const prompt = this.promptBuilder.buildWorkflowSuggestionPrompt(\r\n                request,\r\n                existingWorkflow,\r\n            );\r\n            const response = await this.client.callLLM(prompt, 'workflow_suggestion');\r\n\r\n            const parsed = JSON.parse(response);\r\n            const validated = AIWorkflowSuggestionSchema.parse(parsed);\r\n\r\n            const duration = Date.now() - startTime;\r\n            logger.info(\r\n                {\r\n                    duration,\r\n                    newSectionsCount: validated.newSections.length,\r\n                    newRulesCount: validated.newLogicRules.length,\r\n                    newBlocksCount: validated.newTransformBlocks.length,\r\n                    modificationsCount: validated.modifications.length,\r\n                },\r\n                'AI workflow suggestion succeeded',\r\n            );\r\n\r\n            return validated;\r\n        } catch (error: any) {\r\n            const duration = Date.now() - startTime;\r\n            logger.error({ error, duration }, 'AI workflow suggestion failed');\r\n\r\n            if (error instanceof SyntaxError) {\r\n                throw createAIError(\r\n                    'Failed to parse AI response as JSON',\r\n                    'INVALID_RESPONSE',\r\n                    { originalError: error.message },\r\n                );\r\n            }\r\n\r\n            if (error.name === 'ZodError') {\r\n                throw createAIError(\r\n                    'AI response does not match expected schema',\r\n                    'VALIDATION_ERROR',\r\n                    { originalError: error },\r\n                );\r\n            }\r\n\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Suggest template variable bindings\r\n     * @param request - The binding request containing workflow and template IDs\r\n     * @param variables - Available workflow variables with their aliases\r\n     * @param placeholders - Template placeholders to match\r\n     * @param workflow - Optional workflow structure for alias validation\r\n     */\r\n    async suggestTemplateBindings(\r\n        request: AITemplateBindingsRequest,\r\n        variables: Array<{ alias: string; label: string; type: string }>,\r\n        placeholders: string[],\r\n        workflow?: WorkflowWithAliases,\r\n    ): Promise<AITemplateBindingsResponse> {\r\n        const startTime = Date.now();\r\n\r\n        try {\r\n            const prompt = this.promptBuilder.buildBindingSuggestionPrompt(\r\n                variables,\r\n                placeholders,\r\n            );\r\n            const response = await this.client.callLLM(prompt, 'binding_suggestion');\r\n\r\n            const parsed = JSON.parse(response);\r\n            const validated = AITemplateBindingsResponseSchema.parse(parsed);\r\n\r\n            // Validate suggested aliases against the workflow if provided\r\n            const { validSuggestions, warnings } = this.validateBindingSuggestions(\r\n                validated.suggestions,\r\n                variables,\r\n                workflow,\r\n            );\r\n\r\n            const result: AITemplateBindingsResponse = {\r\n                ...validated,\r\n                suggestions: validSuggestions,\r\n                warnings: [...(validated.warnings || []), ...warnings],\r\n            };\r\n\r\n            const duration = Date.now() - startTime;\r\n            logger.info(\r\n                {\r\n                    duration,\r\n                    suggestionsCount: result.suggestions.length,\r\n                    filteredCount: validated.suggestions.length - validSuggestions.length,\r\n                    warningsCount: warnings.length,\r\n                },\r\n                'AI binding suggestion succeeded',\r\n            );\r\n\r\n            return result;\r\n        } catch (error: any) {\r\n            const duration = Date.now() - startTime;\r\n            logger.error({ error, duration }, 'AI binding suggestion failed');\r\n\r\n            if (error instanceof SyntaxError) {\r\n                throw createAIError(\r\n                    'Failed to parse AI response as JSON',\r\n                    'INVALID_RESPONSE',\r\n                    { originalError: error.message },\r\n                );\r\n            }\r\n\r\n            if (error.name === 'ZodError') {\r\n                throw createAIError(\r\n                    'AI response does not match expected schema',\r\n                    'VALIDATION_ERROR',\r\n                    { originalError: error },\r\n                );\r\n            }\r\n\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validate binding suggestions against available variables and workflow aliases\r\n     */\r\n    private validateBindingSuggestions(\r\n        suggestions: AIBindingSuggestion[],\r\n        variables: Array<{ alias: string; label: string; type: string }>,\r\n        workflow?: WorkflowWithAliases,\r\n    ): { validSuggestions: AIBindingSuggestion[]; warnings: string[] } {\r\n        const validSuggestions: AIBindingSuggestion[] = [];\r\n        const warnings: string[] = [];\r\n\r\n        // Build a set of valid aliases from the provided variables\r\n        const validAliases = new Set(variables.map(v => v.alias.toLowerCase()));\r\n\r\n        // If workflow is provided, also use AliasResolver for comprehensive validation\r\n        let resolver: AliasResolver | undefined;\r\n        if (workflow) {\r\n            resolver = AliasResolver.fromWorkflow(workflow);\r\n        }\r\n\r\n        for (const suggestion of suggestions) {\r\n            const suggestedAlias = suggestion.variable;\r\n            const normalizedAlias = suggestedAlias.toLowerCase();\r\n\r\n            // Check if the alias exists in the provided variables\r\n            const existsInVariables = validAliases.has(normalizedAlias);\r\n\r\n            // If workflow provided, also check via AliasResolver\r\n            const existsInWorkflow = resolver ? resolver.has(suggestedAlias) : true;\r\n\r\n            if (existsInVariables && existsInWorkflow) {\r\n                validSuggestions.push(suggestion);\r\n            } else {\r\n                // Find similar aliases for helpful warning message\r\n                let similarAliases: string[] = [];\r\n                if (resolver) {\r\n                    const allAliases = resolver.getAllAliases();\r\n                    similarAliases = allAliases\r\n                        .filter(alias => {\r\n                            const aliasLower = alias.toLowerCase();\r\n                            return aliasLower.includes(normalizedAlias) ||\r\n                                   normalizedAlias.includes(aliasLower);\r\n                        })\r\n                        .slice(0, 3);\r\n                }\r\n\r\n                const suggestionText = similarAliases.length > 0\r\n                    ? ` Similar aliases: ${similarAliases.join(', ')}`\r\n                    : '';\r\n\r\n                warnings.push(\r\n                    `Filtered binding for placeholder \"${suggestion.placeholder}\": ` +\r\n                    `alias \"${suggestedAlias}\" does not exist in workflow.${suggestionText}`\r\n                );\r\n\r\n                logger.warn(\r\n                    {\r\n                        placeholder: suggestion.placeholder,\r\n                        suggestedAlias,\r\n                        similarAliases,\r\n                    },\r\n                    'Filtered invalid binding suggestion - alias not found',\r\n                );\r\n            }\r\n        }\r\n\r\n        return { validSuggestions, warnings };\r\n    }\r\n\r\n    /**\r\n     * Suggest random plausible values for workflow steps\r\n     * Used for testing and preview data generation\r\n     */\r\n    async suggestValues(\r\n        steps: Array<{\r\n            key: string;\r\n            type: string;\r\n            label?: string;\r\n            options?: string[];\r\n            description?: string;\r\n        }>,\r\n        mode: 'full' | 'partial' = 'full',\r\n    ): Promise<Record<string, any>> {\r\n        const startTime = Date.now();\r\n\r\n        try {\r\n            const prompt = this.promptBuilder.buildValueSuggestionPrompt(steps, mode);\r\n            const response = await this.client.callLLM(prompt, 'value_suggestion');\r\n\r\n            // Parse and return the response\r\n            const parsed = JSON.parse(response);\r\n\r\n            const duration = Date.now() - startTime;\r\n            logger.info(\r\n                {\r\n                    duration,\r\n                    stepCount: steps.length,\r\n                    mode,\r\n                },\r\n                'AI value suggestion succeeded',\r\n            );\r\n\r\n            return parsed.values || parsed;\r\n        } catch (error: any) {\r\n            const duration = Date.now() - startTime;\r\n            logger.error({ error, duration }, 'AI value suggestion failed');\r\n\r\n            if (error instanceof SyntaxError) {\r\n                throw createAIError(\r\n                    'Failed to parse AI response as JSON',\r\n                    'INVALID_RESPONSE',\r\n                    { originalError: error.message },\r\n                );\r\n            }\r\n\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n\r\n// Singleton export removed - services create their own instances via dependency injection\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\index.ts","messages":[{"ruleId":"import/export","severity":2,"message":"Multiple exports of name 'createAIError'.","line":15,"column":1,"nodeType":"ExportAllDeclaration","endLine":15,"endColumn":34},{"ruleId":"import/export","severity":2,"message":"Multiple exports of name 'getRetryAfter'.","line":15,"column":1,"nodeType":"ExportAllDeclaration","endLine":15,"endColumn":34},{"ruleId":"import/export","severity":2,"message":"Multiple exports of name 'createAIError'.","line":29,"column":19,"nodeType":"Identifier","endLine":29,"endColumn":32},{"ruleId":"import/export","severity":2,"message":"Multiple exports of name 'getRetryAfter'.","line":29,"column":68,"nodeType":"Identifier","endLine":29,"endColumn":81}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * AI Services Module\r\n *\r\n * Central export point for all AI-related services\r\n */\r\n\r\nexport { AIPromptBuilder, aiPromptBuilder } from './AIPromptBuilder';\r\nexport { WorkflowOptimizationService, workflowOptimizationService } from './WorkflowOptimizationService';\r\nexport { AIProviderClient } from './AIProviderClient';\r\n// Services\r\nexport { WorkflowGenerationService } from './WorkflowGenerationService';\r\nexport { WorkflowSuggestionService } from './WorkflowSuggestionService';\r\nexport { WorkflowRevisionService } from './WorkflowRevisionService';\r\n\r\nexport * from './AIServiceUtils';\r\n// Avoid exporting duplicated members\r\nexport type {\r\n    AIErrorCode,\r\n    TokenEstimate,\r\n    CostEstimate,\r\n    TruncationCheck,\r\n    AIGeneratedWorkflow,\r\n    AIGeneratedStep,\r\n    AIGeneratedSection,\r\n    AIGeneratedLogicRule,\r\n    AIGeneratedTransformBlock\r\n} from './types';\r\nexport { ModelRegistry } from './ModelRegistry';\r\nexport { AIError, createAIError, isRateLimitError, isTimeoutError, getRetryAfter } from './AIError';\r\nexport { ProviderFactory } from './providers/ProviderFactory';\r\nexport * from './providers/types';\r\n\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\providers\\AnthropicProvider.ts","messages":[{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Import name `Anthropic` must match one of the following formats: camelCase","line":1,"column":8,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":1,"endColumn":17},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":30,"column":31,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":30,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[950,959],"text":"(maxTokens != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[950,959],"text":"(maxTokens ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[950,959],"text":"(Boolean(maxTokens))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":30,"column":41,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":30,"endColumn":43,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[960,962],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `max_tokens` must match one of the following formats: camelCase","line":38,"column":17,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":38,"endColumn":27},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":41,"column":39,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":41,"endColumn":41,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[1378,1380],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Anthropic from '@anthropic-ai/sdk';\r\n\r\nimport { createLogger } from '../../../logger';\r\n\r\nimport { BaseAIProvider } from './BaseAIProvider';\r\n\r\nimport type { TaskType } from '../types';\r\nimport type { AIProviderConfig } from './types';\r\n\r\nconst logger = createLogger({ module: 'anthropic-provider' });\r\n\r\nexport class AnthropicProvider extends BaseAIProvider {\r\n    readonly providerName = 'anthropic';\r\n    private client: Anthropic;\r\n\r\n    constructor(config: AIProviderConfig) {\r\n        super(config);\r\n        this.client = new Anthropic({ apiKey: config.apiKey, timeout: 600000 });\r\n    }\r\n\r\n    async generateResponse(\r\n        prompt: string,\r\n        taskType: TaskType,\r\n        systemMessage?: string\r\n    ): Promise<string> {\r\n        const { model, temperature = 0.7, maxTokens } = this.config;\r\n        const startTime = Date.now();\r\n        const promptTokens = this.estimateTokenCount(prompt);\r\n\r\n        const safeMaxTokens = maxTokens || 4000;\r\n        this.validateTokenLimits(prompt, safeMaxTokens);\r\n\r\n        logger.debug({ model, taskType }, 'Calling Anthropic');\r\n\r\n        try {\r\n            const response = await this.client.messages.create({\r\n                model,\r\n                max_tokens: safeMaxTokens,\r\n                temperature,\r\n                messages: [{ role: 'user', content: prompt }],\r\n                system: systemMessage || 'You are a workflow design expert. You output only valid JSON with no additional text or markdown formatting. Never wrap your JSON in markdown code blocks.',\r\n            });\r\n\r\n            const content = response.content[0];\r\n            if (content.type !== 'text') {\r\n                throw this.createError('Unexpected Anthropic response type', 'INVALID_RESPONSE');\r\n            }\r\n\r\n            // Strip markdown code blocks\r\n            let text = content.text.trim();\r\n            if (text.startsWith('```json')) {\r\n                text = text.replace(/^```json\\n/, '').replace(/\\n```$/, '');\r\n            } else if (text.startsWith('```')) {\r\n                text = text.replace(/^```\\n/, '').replace(/\\n```$/, '');\r\n            }\r\n\r\n            const responseTokens = this.estimateTokenCount(text);\r\n            const duration = Date.now() - startTime;\r\n            const actualCost = this.estimateCost(promptTokens, responseTokens);\r\n\r\n            logger.info({\r\n                event: 'ai_request_success',\r\n                provider: this.providerName,\r\n                model,\r\n                taskType,\r\n                promptTokens,\r\n                responseTokens,\r\n                durationMs: duration,\r\n                estimatedCostUSD: actualCost,\r\n            }, 'Anthropic request succeeded');\r\n\r\n            return text;\r\n        } catch (error) {\r\n            logger.error({ error }, 'Anthropic request failed');\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\providers\\BaseAIProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `AIProvider` assigned to a parameter of type `AIProvider`.","line":44,"column":50,"nodeType":"TSAsExpression","messageId":"unsafeArgument","endLine":44,"endColumn":84},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `AIProvider` assigned to a parameter of type `AIProvider`.","line":52,"column":13,"nodeType":"TSAsExpression","messageId":"unsafeArgument","endLine":52,"endColumn":47},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":113,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3870,3873],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3870,3873],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":134,"column":50,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":134,"endColumn":52,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[4683,4685],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":135,"column":51,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":135,"endColumn":53,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[4749,4751],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":136,"column":52,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":136,"endColumn":54,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[4816,4818],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":137,"column":53,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":137,"endColumn":55,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[4884,4886],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createLogger } from '../../../logger';\r\nimport { AIError } from '../AIError';\r\nimport { ModelRegistry } from '../ModelRegistry';\r\n\r\nimport type { TaskType, AIErrorCode } from '../types';\r\nimport type { IAIProvider, AIProviderConfig } from './types';\r\nimport type { AIProvider } from '../../../shared/types/ai';\r\n\r\nconst logger = createLogger({ module: 'ai-provider' });\r\n\r\n/**\r\n * Abstract base class for AI providers\r\n * Implements common utilities for token counting, validation, and logging\r\n */\r\nexport abstract class BaseAIProvider implements IAIProvider {\r\n    abstract readonly providerName: string;\r\n    protected config: AIProviderConfig;\r\n\r\n    constructor(config: AIProviderConfig) {\r\n        this.config = config;\r\n    }\r\n\r\n    /**\r\n     * Generate response - must be implemented by subclasses\r\n     */\r\n    abstract generateResponse(\r\n        prompt: string,\r\n        taskType: TaskType,\r\n        systemMessage?: string\r\n    ): Promise<string>;\r\n\r\n    /**\r\n     * Estimate token count from text (rough approximation: 1 token  4 characters)\r\n     * Subclasses can override this if they have more accurate tokenizers\r\n     */\r\n    estimateTokenCount(text: string): number {\r\n        return Math.ceil(text.length / 4);\r\n    }\r\n\r\n    /**\r\n     * Get max context tokens using ModelRegistry\r\n     */\r\n    getMaxContextTokens(): number {\r\n        return ModelRegistry.getMaxContextTokens(this.config.provider as AIProvider, this.config.model);\r\n    }\r\n\r\n    /**\r\n     * Estimate cost using ModelRegistry\r\n     */\r\n    estimateCost(promptTokens: number, responseTokens: number): number {\r\n        return ModelRegistry.estimateCost(\r\n            this.config.provider as AIProvider,\r\n            this.config.model,\r\n            promptTokens,\r\n            responseTokens\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Validate that prompt + response won't exceed context window\r\n     */\r\n    protected validateTokenLimits(prompt: string, maxResponseTokens: number): void {\r\n        const promptTokens = this.estimateTokenCount(prompt);\r\n        const maxContext = this.getMaxContextTokens();\r\n        const totalTokens = promptTokens + maxResponseTokens;\r\n\r\n        logger.debug({\r\n            promptTokens,\r\n            maxResponseTokens,\r\n            totalTokens,\r\n            maxContext,\r\n            provider: this.providerName,\r\n            model: this.config.model,\r\n        }, 'Token usage estimate');\r\n\r\n        if (totalTokens > maxContext) {\r\n            const errorMsg = [\r\n                `Request exceeds model's context window:`,\r\n                `  Prompt: ~${promptTokens.toLocaleString()} tokens`,\r\n                `  Expected response: ~${maxResponseTokens.toLocaleString()} tokens`,\r\n                `  Total: ~${totalTokens.toLocaleString()} tokens`,\r\n                `  Model limit: ${maxContext.toLocaleString()} tokens`,\r\n                ``,\r\n                `The workflow or request is too large for the AI model to process.`,\r\n            ].join('\\n');\r\n\r\n            throw this.createError(errorMsg, 'VALIDATION_ERROR', {\r\n                promptTokens,\r\n                maxResponseTokens,\r\n                totalTokens,\r\n                maxContext,\r\n                provider: this.providerName,\r\n                model: this.config.model,\r\n            });\r\n        }\r\n\r\n        // Warn if we're using >80% of context window\r\n        const usagePercent = (totalTokens / maxContext) * 100;\r\n        if (usagePercent > 80) {\r\n            logger.warn({\r\n                promptTokens,\r\n                maxResponseTokens,\r\n                totalTokens,\r\n                maxContext,\r\n                usagePercent: usagePercent.toFixed(1),\r\n            }, 'High token usage - approaching context limit');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper to create typed AI errors\r\n     */\r\n    protected createError(message: string, code: string, details?: any): AIError {\r\n        return new AIError(message, code as AIErrorCode, details);\r\n    }\r\n\r\n    /**\r\n     * Detect if JSON response appears truncated\r\n     */\r\n    public isResponseTruncated(response: string): boolean {\r\n        const trimmed = response.trim();\r\n\r\n        // Check 1: Response should end with closing brace or bracket\r\n        const endsCorrectly = trimmed.endsWith('}') || trimmed.endsWith(']');\r\n        if (!endsCorrectly) {\r\n            logger.warn({\r\n                lastChar: trimmed.charAt(trimmed.length - 1),\r\n                last50: trimmed.substring(trimmed.length - 50),\r\n            }, 'Response does not end with closing brace/bracket');\r\n            return true;\r\n        }\r\n\r\n        // Check 2: Count opening vs closing braces\r\n        const openBraces = (trimmed.match(/\\{/g) || []).length;\r\n        const closeBraces = (trimmed.match(/\\}/g) || []).length;\r\n        const openBrackets = (trimmed.match(/\\[/g) || []).length;\r\n        const closeBrackets = (trimmed.match(/\\]/g) || []).length;\r\n\r\n        if (openBraces !== closeBraces || openBrackets !== closeBrackets) {\r\n            logger.warn({\r\n                openBraces,\r\n                closeBraces,\r\n                openBrackets,\r\n                closeBrackets,\r\n            }, 'Mismatched braces/brackets detected');\r\n            return true;\r\n        }\r\n\r\n        // Check 3: Try to parse as JSON\r\n        try {\r\n            JSON.parse(trimmed);\r\n            return false;\r\n        } catch (parseError) {\r\n            logger.warn({\r\n                parseError: parseError instanceof Error ? parseError.message : String(parseError),\r\n                last100: trimmed.substring(Math.max(0, trimmed.length - 100)),\r\n            }, 'JSON parsing failed - response appears truncated');\r\n            return true;\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\providers\\GeminiProvider.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":31,"column":31,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":31,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1077,1086],"text":"(maxTokens != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[1077,1086],"text":"(maxTokens ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1077,1086],"text":"(Boolean(maxTokens))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":31,"column":41,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":31,"endColumn":43,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[1087,1089],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GoogleGenerativeAI } from '@google/generative-ai';\r\n\r\nimport { createLogger } from '../../../logger';\r\n\r\nimport { BaseAIProvider } from './BaseAIProvider';\r\n\r\nimport type { TaskType } from '../types';\r\nimport type { AIProviderConfig } from './types';\r\n\r\nconst logger = createLogger({ module: 'gemini-provider' });\r\n\r\nexport class GeminiProvider extends BaseAIProvider {\r\n    readonly providerName = 'gemini';\r\n    private client: ReturnType<GoogleGenerativeAI['getGenerativeModel']>;\r\n\r\n    constructor(config: AIProviderConfig) {\r\n        super(config);\r\n        const genAI = new GoogleGenerativeAI(config.apiKey);\r\n        this.client = genAI.getGenerativeModel({ model: config.model }, { timeout: 600000 });\r\n    }\r\n\r\n    async generateResponse(\r\n        prompt: string,\r\n        taskType: TaskType,\r\n        _systemMessage?: string\r\n    ): Promise<string> {\r\n        const { model, temperature = 0.7, maxTokens } = this.config;\r\n        const startTime = Date.now();\r\n        const promptTokens = this.estimateTokenCount(prompt);\r\n\r\n        const safeMaxTokens = maxTokens || 4000;\r\n        this.validateTokenLimits(prompt, safeMaxTokens);\r\n\r\n        logger.debug({ model, taskType }, 'Calling Gemini');\r\n\r\n        try {\r\n            // Note: Gemini API handles system prompts differently or not at all depending on model version/SDK\r\n            // For now we append it to the prompt if critical, or assume the model follows instructions well.\r\n            // The original implementation had a single prompt part.\r\n\r\n            const result = await this.client.generateContent({\r\n                contents: [{ role: 'user', parts: [{ text: prompt }] }],\r\n                generationConfig: {\r\n                    temperature,\r\n                    maxOutputTokens: safeMaxTokens,\r\n                },\r\n            });\r\n\r\n            const response = result.response;\r\n            const content = response.text();\r\n\r\n            if (!content) {\r\n                throw this.createError('No content in Gemini response', 'INVALID_RESPONSE');\r\n            }\r\n\r\n            // Strip markdown code blocks\r\n            let text = content.trim();\r\n            if (text.startsWith('```json')) {\r\n                text = text.replace(/^```json\\n/, '').replace(/\\n```$/, '');\r\n            } else if (text.startsWith('```')) {\r\n                text = text.replace(/^```\\n/, '').replace(/\\n```$/, '');\r\n            }\r\n\r\n            const responseTokens = this.estimateTokenCount(text);\r\n            const duration = Date.now() - startTime;\r\n            const actualCost = this.estimateCost(promptTokens, responseTokens);\r\n\r\n            logger.info({\r\n                event: 'ai_request_success',\r\n                provider: this.providerName,\r\n                model,\r\n                taskType,\r\n                promptTokens,\r\n                responseTokens,\r\n                durationMs: duration,\r\n                estimatedCostUSD: actualCost,\r\n            }, 'Gemini request succeeded');\r\n\r\n            return text;\r\n        } catch (error) {\r\n            logger.error({ error }, 'Gemini request failed');\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\providers\\OpenAIProvider.ts","messages":[{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Import name `OpenAI` must match one of the following formats: camelCase","line":1,"column":8,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":1,"endColumn":14},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":2,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":32,"column":31,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":32,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1086,1095],"text":"(maxTokens != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[1086,1095],"text":"(maxTokens ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1086,1095],"text":"(Boolean(maxTokens))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":32,"column":41,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":32,"endColumn":43,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[1096,1098],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `max_tokens` must match one of the following formats: camelCase","line":56,"column":17,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":56,"endColumn":27},{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Object Literal Property name `response_format` must match one of the following formats: camelCase","line":57,"column":17,"nodeType":"Identifier","messageId":"doesNotMatchFormat","endLine":57,"endColumn":32}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import OpenAI from 'openai';\r\n\r\nimport { createLogger } from '../../../logger';\r\n\r\nimport { BaseAIProvider } from './BaseAIProvider';\r\n\r\nimport type { TaskType } from '../types';\r\nimport type { AIProviderConfig } from './types';\r\n\r\nconst logger = createLogger({ module: 'openai-provider' });\r\n\r\nexport class OpenAIProvider extends BaseAIProvider {\r\n    readonly providerName = 'openai';\r\n    private client: OpenAI;\r\n\r\n    constructor(config: AIProviderConfig) {\r\n        super(config);\r\n        this.client = new OpenAI({ apiKey: config.apiKey, timeout: 600000 });\r\n    }\r\n\r\n    async generateResponse(\r\n        prompt: string,\r\n        taskType: TaskType,\r\n        systemMessage?: string\r\n    ): Promise<string> {\r\n        const { model, temperature = 0.7, maxTokens } = this.config;\r\n        const startTime = Date.now();\r\n        const promptTokens = this.estimateTokenCount(prompt); // Rough estimate\r\n\r\n        // Validate limits before calling\r\n        // Note: We use a safe default if maxTokens is undefined, logic mirrored from original service\r\n        const safeMaxTokens = maxTokens || 4000;\r\n        this.validateTokenLimits(prompt, safeMaxTokens);\r\n\r\n        logger.debug({ model, taskType }, 'Calling OpenAI');\r\n\r\n        try {\r\n            const messages: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [];\r\n\r\n            if (systemMessage) {\r\n                messages.push({ role: 'system', content: systemMessage });\r\n            } else {\r\n                // Default system message if none provided\r\n                messages.push({\r\n                    role: 'system',\r\n                    content: 'You are a workflow design expert. You output only valid JSON with no additional text or markdown formatting.'\r\n                });\r\n            }\r\n\r\n            messages.push({ role: 'user', content: prompt });\r\n\r\n            const response = await this.client.chat.completions.create({\r\n                model,\r\n                messages,\r\n                temperature,\r\n                max_tokens: safeMaxTokens,\r\n                response_format: { type: 'json_object' },\r\n            });\r\n\r\n            const content = response.choices[0]?.message?.content;\r\n            if (!content) {\r\n                throw this.createError('No content in OpenAI response', 'INVALID_RESPONSE');\r\n            }\r\n\r\n            const responseTokens = this.estimateTokenCount(content);\r\n            const duration = Date.now() - startTime;\r\n            const actualCost = this.estimateCost(promptTokens, responseTokens);\r\n\r\n            logger.info({\r\n                event: 'ai_request_success',\r\n                provider: this.providerName,\r\n                model,\r\n                taskType,\r\n                promptTokens,\r\n                responseTokens,\r\n                durationMs: duration,\r\n                estimatedCostUSD: actualCost,\r\n            }, 'OpenAI request succeeded');\r\n\r\n            return content;\r\n        } catch (error) {\r\n            logger.error({ error }, 'OpenAI request failed');\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\providers\\ProviderFactory.ts","messages":[{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"never\" of template literal expression.","line":35,"column":53,"nodeType":"Identifier","messageId":"invalidType","endLine":35,"endColumn":61}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Provider Factory\r\n *\r\n * Creates the appropriate AI provider instance based on configuration\r\n */\r\n\r\nimport { AnthropicProvider } from './AnthropicProvider';\r\nimport { GeminiProvider } from './GeminiProvider';\r\nimport { OpenAIProvider } from './OpenAIProvider';\r\n\r\nimport type { IAIProvider, AIProviderConfig } from './types';\r\nimport type { AIProvider } from '../../../../shared/types/ai';\r\n\r\n/**\r\n * Factory for creating AI provider instances\r\n */\r\nexport class ProviderFactory {\r\n  /**\r\n   * Create a provider instance based on configuration\r\n   */\r\n  static createProvider(config: AIProviderConfig): IAIProvider {\r\n    const provider = config.provider as AIProvider;\r\n\r\n    switch (provider) {\r\n      case 'openai':\r\n        return new OpenAIProvider(config);\r\n\r\n      case 'anthropic':\r\n        return new AnthropicProvider(config);\r\n\r\n      case 'gemini':\r\n        return new GeminiProvider(config);\r\n\r\n      default:\r\n        throw new Error(`Unsupported AI provider: ${provider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate provider configuration\r\n   */\r\n  static validateConfig(config: AIProviderConfig): void {\r\n    if (!config.provider) {\r\n      throw new Error('Provider is required');\r\n    }\r\n\r\n    if (!config.apiKey) {\r\n      throw new Error('API key is required');\r\n    }\r\n\r\n    if (!config.model) {\r\n      throw new Error('Model is required');\r\n    }\r\n\r\n    const supportedProviders: AIProvider[] = ['openai', 'anthropic', 'gemini'];\r\n    if (!supportedProviders.includes(config.provider as AIProvider)) {\r\n      throw new Error(\r\n        `Unsupported provider: ${config.provider}. Supported providers: ${supportedProviders.join(', ')}`\r\n      );\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\providers\\types.ts","messages":[{"ruleId":"@typescript-eslint/naming-convention","severity":2,"message":"Interface name `IAIProvider` must not match the RegExp: /^I[A-Z]/u","line":17,"column":18,"nodeType":"Identifier","messageId":"satisfyCustom","endLine":17,"endColumn":29}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TaskType } from '../types';\r\n\r\n/**\r\n * Common configuration for all AI providers\r\n */\r\nexport interface AIProviderConfig {\r\n    provider: string;\r\n    apiKey: string;\r\n    model: string;\r\n    maxTokens?: number;\r\n    temperature?: number;\r\n}\r\n\r\n/**\r\n * Interface that all AI providers must implement\r\n */\r\nexport interface IAIProvider {\r\n    /**\r\n     * The provider identifier (openai, anthropic, gemini)\r\n     */\r\n    readonly providerName: string;\r\n\r\n    /**\r\n     * Generate a response from the LLM\r\n     */\r\n    generateResponse(\r\n        prompt: string,\r\n        taskType: TaskType,\r\n        systemMessage?: string\r\n    ): Promise<string>;\r\n\r\n    /**\r\n     * Estimate token count for a text string\r\n     */\r\n    estimateTokenCount(text: string): number;\r\n\r\n    /**\r\n     * Calculate exact or estimated cost for a request\r\n     */\r\n    estimateCost(promptTokens: number, responseTokens: number): number;\r\n\r\n    /**\r\n     * Get maximum context window for the current model\r\n     */\r\n    getMaxContextTokens(): number;\r\n\r\n    /**\r\n     * Check if response appears to be truncated\r\n     */\r\n    isResponseTruncated(response: string): boolean;\r\n}\r\n","usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Users\\scoot\\poll\\ezBuildr\\server\\services\\ai\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"@typescript-eslint/no-throw-literal","replacedBy":["@typescript-eslint/only-throw-error"]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]